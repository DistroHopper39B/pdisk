<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>partition_map.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">partition_map.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="partition_map.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">//
</span><span class="enscript-comment">// partition_map.c - partition map routines
</span><span class="enscript-comment">//
</span><span class="enscript-comment">// Written by Eryk Vershen
</span><span class="enscript-comment">//
</span>
<span class="enscript-comment">/*
 * Copyright 1996,1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 */</span>

<span class="enscript-comment">// for *printf()
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>

<span class="enscript-comment">// for malloc(), calloc() &amp; free()
</span>#<span class="enscript-reference">ifndef</span> <span class="enscript-variable-name">__linux__</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;malloc.h&gt;</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">// for strncpy() &amp; strcmp()
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;string.h&gt;</span>
<span class="enscript-comment">// for O_RDONLY &amp; O_RDWR
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;fcntl.h&gt;</span>
<span class="enscript-comment">// for errno
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;errno.h&gt;</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;partition_map.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;pathname.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;hfs_misc.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;deblock_media.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;io.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;convert.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;util.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;errors.h&quot;</span>


<span class="enscript-comment">//
</span><span class="enscript-comment">// Defines
</span><span class="enscript-comment">//
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">APPLE_HFS_FLAGS_VALUE</span>	0x4000037f
#<span class="enscript-reference">define</span> <span class="enscript-function-name">get_align_long</span>(x)	(*(x))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">put_align_long</span>(y, x)	((*(x)) = (y))
<span class="enscript-comment">// #define TEST_COMPUTE
</span>

<span class="enscript-comment">//
</span><span class="enscript-comment">// Types
</span><span class="enscript-comment">//
</span>

<span class="enscript-comment">//
</span><span class="enscript-comment">// Global Constants
</span><span class="enscript-comment">//
</span><span class="enscript-type">const</span> <span class="enscript-type">char</span> * kFreeType	= <span class="enscript-string">&quot;Apple_Free&quot;</span>;
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kMapType	= <span class="enscript-string">&quot;Apple_partition_map&quot;</span>;
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kUnixType	= <span class="enscript-string">&quot;Apple_UNIX_SVR2&quot;</span>;
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kHFSType	= <span class="enscript-string">&quot;Apple_HFS&quot;</span>;
<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kPatchType	= <span class="enscript-string">&quot;Apple_Patches&quot;</span>;

<span class="enscript-type">const</span> <span class="enscript-type">char</span> * kFreeName	= <span class="enscript-string">&quot;Extra&quot;</span>;

<span class="enscript-type">enum</span> add_action {
    kReplace = 0,
    kAdd = 1,
    kSplit = 2
};

<span class="enscript-comment">//
</span><span class="enscript-comment">// Global Variables
</span><span class="enscript-comment">//
</span><span class="enscript-type">extern</span> <span class="enscript-type">int</span> cflag;


<span class="enscript-comment">//
</span><span class="enscript-comment">// Forward declarations
</span><span class="enscript-comment">//
</span><span class="enscript-type">int</span> <span class="enscript-function-name">add_data_to_map</span>(<span class="enscript-type">struct</span> dpme *, <span class="enscript-type">long</span>, partition_map_header *);
<span class="enscript-type">int</span> <span class="enscript-function-name">coerce_block0</span>(partition_map_header *map);
<span class="enscript-type">int</span> <span class="enscript-function-name">contains_driver</span>(partition_map *entry);
<span class="enscript-type">void</span> <span class="enscript-function-name">combine_entry</span>(partition_map *entry);
<span class="enscript-type">long</span> <span class="enscript-function-name">compute_device_size</span>(partition_map_header *map, partition_map_header *oldmap);
DPME* <span class="enscript-function-name">create_data</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dptype, u32 base, u32 length);
<span class="enscript-type">void</span> <span class="enscript-function-name">delete_entry</span>(partition_map *entry);
<span class="enscript-type">char</span> *<span class="enscript-function-name">get_HFS_name</span>(partition_map *entry, <span class="enscript-type">int</span> *kind);
<span class="enscript-type">void</span> <span class="enscript-function-name">insert_in_base_order</span>(partition_map *entry);
<span class="enscript-type">void</span> <span class="enscript-function-name">insert_in_disk_order</span>(partition_map *entry);
<span class="enscript-type">int</span> <span class="enscript-function-name">read_block</span>(partition_map_header *map, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> num, <span class="enscript-type">char</span> *buf);
<span class="enscript-type">int</span> <span class="enscript-function-name">read_partition_map</span>(partition_map_header *map);
<span class="enscript-type">void</span> <span class="enscript-function-name">remove_driver</span>(partition_map *entry);
<span class="enscript-type">void</span> <span class="enscript-function-name">remove_from_disk_order</span>(partition_map *entry);
<span class="enscript-type">void</span> <span class="enscript-function-name">renumber_disk_addresses</span>(partition_map_header *map);
<span class="enscript-type">void</span> <span class="enscript-function-name">sync_device_size</span>(partition_map_header *map);
<span class="enscript-type">int</span> <span class="enscript-function-name">write_block</span>(partition_map_header *map, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> num, <span class="enscript-type">char</span> *buf);


<span class="enscript-comment">//
</span><span class="enscript-comment">// Routines
</span><span class="enscript-comment">//
</span>partition_map_header *
<span class="enscript-function-name">open_partition_map</span>(<span class="enscript-type">char</span> *name, <span class="enscript-type">int</span> *valid_file, <span class="enscript-type">int</span> ask_logical_size, <span class="enscript-type">int</span> oflag)
{
    MEDIA m;
    partition_map_header * map;
    <span class="enscript-type">int</span> writable;
    <span class="enscript-type">long</span> size;

    m = open_pathname_as_media(name, oflag);
    <span class="enscript-keyword">if</span> (m == 0) {
	m = open_pathname_as_media(name, O_RDONLY);
	<span class="enscript-keyword">if</span> (m == 0) {
	    error(errno, <span class="enscript-string">&quot;can't open file '%s'&quot;</span>, name);
	    *valid_file = 0;
	    <span class="enscript-keyword">return</span> NULL;
	} <span class="enscript-keyword">else</span> {
	    writable = 0;
	}
    } <span class="enscript-keyword">else</span> {
	writable = 1;
    }
    *valid_file = 1;

    map = (partition_map_header *) malloc(<span class="enscript-keyword">sizeof</span>(partition_map_header));
    <span class="enscript-keyword">if</span> (map == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for open partition map&quot;</span>);
	close_media(m);
	<span class="enscript-keyword">return</span> NULL;
    }
    map-&gt;name = name;
    map-&gt;writable = (oflag == O_RDONLY)?0:writable;
    map-&gt;changed = 0;
    map-&gt;written = 0;
    map-&gt;disk_order = NULL;
    map-&gt;base_order = NULL;

    map-&gt;physical_block = media_granularity(m);	<span class="enscript-comment">/* preflight */</span>
    m = open_deblock_media(PBLOCK_SIZE, m);
    map-&gt;m = m;
    map-&gt;misc = (Block0 *) malloc(PBLOCK_SIZE);
    <span class="enscript-keyword">if</span> (map-&gt;misc == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for block zero buffer&quot;</span>);
	close_media(map-&gt;m);
	free(map);
	<span class="enscript-keyword">return</span> NULL;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (read_media(map-&gt;m, (<span class="enscript-type">long</span> <span class="enscript-type">long</span>) 0, PBLOCK_SIZE, (<span class="enscript-type">char</span> *)map-&gt;misc) == 0
	    || convert_block0(map-&gt;misc, 1)
	    || coerce_block0(map)) {
	<span class="enscript-comment">// if I can't read block 0 I might as well give up
</span>	error(-1, <span class="enscript-string">&quot;Can't read block 0 from '%s'&quot;</span>, name);
	close_partition_map(map);
	<span class="enscript-keyword">return</span> NULL;
    }
    map-&gt;physical_block = map-&gt;misc-&gt;sbBlkSize;
    <span class="enscript-comment">//printf(&quot;physical block size is %d\n&quot;, map-&gt;physical_block);
</span>
    <span class="enscript-keyword">if</span> (ask_logical_size &amp;&amp; interactive) {
	size = PBLOCK_SIZE;
	printf(<span class="enscript-string">&quot;A logical block is %ld bytes: &quot;</span>, size);
	flush_to_newline(0);
	get_number_argument(<span class="enscript-string">&quot;what should be the logical block size? &quot;</span>,
		&amp;size, size);
	size = (size / PBLOCK_SIZE) * PBLOCK_SIZE;
	<span class="enscript-keyword">if</span> (size &lt; PBLOCK_SIZE) {
	    size = PBLOCK_SIZE;
	}
	map-&gt;logical_block = size;
    } <span class="enscript-keyword">else</span> {
	map-&gt;logical_block = PBLOCK_SIZE;
    }
    <span class="enscript-keyword">if</span> (map-&gt;logical_block &gt; MAXIOSIZE) {
	map-&gt;logical_block = MAXIOSIZE;
    }
    <span class="enscript-keyword">if</span> (map-&gt;logical_block &gt; map-&gt;physical_block) {
	map-&gt;physical_block = map-&gt;logical_block;
    }
    map-&gt;blocks_in_map = 0;
    map-&gt;maximum_in_map = -1;
    map-&gt;media_size = compute_device_size(map, map);

    <span class="enscript-keyword">if</span> (read_partition_map(map) &lt; 0) {
	<span class="enscript-comment">// some sort of failure reading the map
</span>    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">// got it!
</span>	;
	<span class="enscript-keyword">return</span> map;
    }
    close_partition_map(map);
    <span class="enscript-keyword">return</span> NULL;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">close_partition_map</span>(partition_map_header *map)
{
    partition_map * entry;
    partition_map * next;

    <span class="enscript-keyword">if</span> (map == NULL) {
	<span class="enscript-keyword">return</span>;
    }

    free(map-&gt;misc);

    <span class="enscript-keyword">for</span> (entry = map-&gt;disk_order; entry != NULL; entry = next) {
	next = entry-&gt;next_on_disk;
	free(entry-&gt;data);
	free(entry-&gt;HFS_name);
	free(entry);
    }
    close_media(map-&gt;m);
    free(map);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">read_partition_map</span>(partition_map_header *map)
{
    DPME *data;
    u32 limit;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> ix;
    <span class="enscript-type">int</span> old_logical;
    <span class="enscript-type">double</span> d;

<span class="enscript-comment">//printf(&quot;called read_partition_map\n&quot;);
</span><span class="enscript-comment">//printf(&quot;logical = %d, physical = %d\n&quot;, map-&gt;logical_block, map-&gt;physical_block);
</span>    data = (DPME *) malloc(PBLOCK_SIZE);
    <span class="enscript-keyword">if</span> (data == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for disk buffers&quot;</span>);
	<span class="enscript-keyword">return</span> -1;
    }

    <span class="enscript-keyword">if</span> (read_block(map, 1, (<span class="enscript-type">char</span> *)data) == 0) {
	error(-1, <span class="enscript-string">&quot;Can't read block 1 from '%s'&quot;</span>, map-&gt;name);
	free(data);
	<span class="enscript-keyword">return</span> -1;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (convert_dpme(data, 1)
	    || data-&gt;dpme_signature != DPME_SIGNATURE) {
	old_logical = map-&gt;logical_block;
	map-&gt;logical_block = 512;
	<span class="enscript-keyword">while</span> (map-&gt;logical_block &lt;= map-&gt;physical_block) {
	    <span class="enscript-keyword">if</span> (read_block(map, 1, (<span class="enscript-type">char</span> *)data) == 0) {
		error(-1, <span class="enscript-string">&quot;Can't read block 1 from '%s'&quot;</span>, map-&gt;name);
		free(data);
		<span class="enscript-keyword">return</span> -1;
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (convert_dpme(data, 1) == 0
		    &amp;&amp; data-&gt;dpme_signature == DPME_SIGNATURE) {
		d = map-&gt;media_size;
		map-&gt;media_size =  (d * old_logical) / map-&gt;logical_block;
		<span class="enscript-keyword">break</span>;
	    }
	    map-&gt;logical_block *= 2;
	}
	<span class="enscript-keyword">if</span> (map-&gt;logical_block &gt; map-&gt;physical_block) {
	    error(-1, <span class="enscript-string">&quot;No valid block 1 on '%s'&quot;</span>, map-&gt;name);
	    free(data);
	    <span class="enscript-keyword">return</span> -1;
	}
    }
<span class="enscript-comment">//printf(&quot;logical = %d, physical = %d\n&quot;, map-&gt;logical_block, map-&gt;physical_block);
</span>
    limit = data-&gt;dpme_map_entries;
    ix = 1;
    <span class="enscript-keyword">while</span> (1) {
	<span class="enscript-keyword">if</span> (add_data_to_map(data, ix, map) == 0) {
	    free(data);
	    <span class="enscript-keyword">return</span> -1;
	}

	<span class="enscript-keyword">if</span> (ix &gt;= limit) {
	    <span class="enscript-keyword">break</span>;
	} <span class="enscript-keyword">else</span> {
	    ix++;
	}

	data = (DPME *) malloc(PBLOCK_SIZE);
	<span class="enscript-keyword">if</span> (data == NULL) {
	    error(errno, <span class="enscript-string">&quot;can't allocate memory for disk buffers&quot;</span>);
	    <span class="enscript-keyword">return</span> -1;
	}

	<span class="enscript-keyword">if</span> (read_block(map, ix, (<span class="enscript-type">char</span> *)data) == 0) {
	    error(-1, <span class="enscript-string">&quot;Can't read block %u from '%s'&quot;</span>, ix, map-&gt;name);
	    free(data);
	    <span class="enscript-keyword">return</span> -1;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (convert_dpme(data, 1)
		|| (data-&gt;dpme_signature != DPME_SIGNATURE &amp;&amp; dflag == 0)
		|| (data-&gt;dpme_map_entries != limit &amp;&amp; dflag == 0)) {
	    error(-1, <span class="enscript-string">&quot;Bad data in block %u from '%s'&quot;</span>, ix, map-&gt;name);
	    free(data);
	    <span class="enscript-keyword">return</span> -1;
	}
    }
    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">write_partition_map</span>(partition_map_header *map)
{
    MEDIA m;
    <span class="enscript-type">char</span> *block;
    partition_map * entry;
    <span class="enscript-type">int</span> i = 0;
    <span class="enscript-type">int</span> result = 0;

    m = map-&gt;m;
    <span class="enscript-keyword">if</span> (map-&gt;misc != NULL) {
	convert_block0(map-&gt;misc, 0);
	result = write_block(map, 0, (<span class="enscript-type">char</span> *)map-&gt;misc);
	convert_block0(map-&gt;misc, 1);
    } <span class="enscript-keyword">else</span> {
	block = (<span class="enscript-type">char</span> *) calloc(1, PBLOCK_SIZE);
	<span class="enscript-keyword">if</span> (block != NULL) {
	    result = write_block(map, 0, block);
	    free(block);
	}
    }
    <span class="enscript-keyword">if</span> (result == 0) {
	error(errno, <span class="enscript-string">&quot;Unable to write block zero&quot;</span>);
    }
    <span class="enscript-keyword">for</span> (entry = map-&gt;disk_order; entry != NULL; entry = entry-&gt;next_on_disk) {
	convert_dpme(entry-&gt;data, 0);
	result = write_block(map, entry-&gt;disk_address, (<span class="enscript-type">char</span> *)entry-&gt;data);
	convert_dpme(entry-&gt;data, 1);
	i = entry-&gt;disk_address;
	<span class="enscript-keyword">if</span> (result == 0) {
	    error(errno, <span class="enscript-string">&quot;Unable to write block %d&quot;</span>, i);
	}
    }

#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">__linux__</span>
	<span class="enscript-comment">// zap the block after the map (if possible) to get around a bug.
</span>    <span class="enscript-keyword">if</span> (map-&gt;maximum_in_map &gt; 0 &amp;&amp;  i &lt; map-&gt;maximum_in_map) {
	i += 1;
	block = (<span class="enscript-type">char</span> *) malloc(PBLOCK_SIZE);
	<span class="enscript-keyword">if</span> (block != NULL) {
	    <span class="enscript-keyword">if</span> (read_block(map, i, block)) {
		block[0] = 0;
		write_block(map, i, block);
	    }
	    free(block);
	}
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (interactive)
	printf(<span class="enscript-string">&quot;The partition table has been altered!\n\n&quot;</span>);

    os_reload_media(map-&gt;m);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">add_data_to_map</span>(<span class="enscript-type">struct</span> dpme *data, <span class="enscript-type">long</span> ix, partition_map_header *map)
{
    partition_map *entry;

<span class="enscript-comment">//printf(&quot;add data %d to map\n&quot;, ix);
</span>    entry = (partition_map *) malloc(<span class="enscript-keyword">sizeof</span>(partition_map));
    <span class="enscript-keyword">if</span> (entry == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for map entries&quot;</span>);
	<span class="enscript-keyword">return</span> 0;
    }
    entry-&gt;next_on_disk = NULL;
    entry-&gt;prev_on_disk = NULL;
    entry-&gt;next_by_base = NULL;
    entry-&gt;prev_by_base = NULL;
    entry-&gt;disk_address = ix;
    entry-&gt;the_map = map;
    entry-&gt;data = data;
    entry-&gt;contains_driver = contains_driver(entry);
    entry-&gt;HFS_name = get_HFS_name(entry, &amp;entry-&gt;HFS_kind);

    insert_in_disk_order(entry);
    insert_in_base_order(entry);

    map-&gt;blocks_in_map++;
    <span class="enscript-keyword">if</span> (map-&gt;maximum_in_map &lt; 0) {
	<span class="enscript-keyword">if</span> (istrncmp(data-&gt;dpme_type, kMapType, DPISTRLEN) == 0) {
	    map-&gt;maximum_in_map = data-&gt;dpme_pblocks;
	}
    }

    <span class="enscript-keyword">return</span> 1;
}


partition_map_header *
<span class="enscript-function-name">init_partition_map</span>(<span class="enscript-type">char</span> *name, partition_map_header* oldmap, <span class="enscript-type">int</span> oflag)
{
    partition_map_header *map;

    <span class="enscript-keyword">if</span> (oldmap != NULL) {
	printf(<span class="enscript-string">&quot;map already exists\n&quot;</span>);
	<span class="enscript-keyword">if</span> (get_okay(<span class="enscript-string">&quot;do you want to reinit? [n/y]: &quot;</span>, 0) != 1) {
	    <span class="enscript-keyword">return</span> oldmap;
	}
    }

    map = create_partition_map(name, oldmap, oflag);
    <span class="enscript-keyword">if</span> (map == NULL) {
	<span class="enscript-keyword">return</span> oldmap;
    }
    close_partition_map(oldmap);

    add_partition_to_map(<span class="enscript-string">&quot;Apple&quot;</span>, kMapType,
	    1, (map-&gt;media_size &lt;= 128? 2: 63), map);
    <span class="enscript-keyword">return</span> map;
}


partition_map_header *
<span class="enscript-function-name">create_partition_map</span>(<span class="enscript-type">char</span> *name, partition_map_header *oldmap, <span class="enscript-type">int</span> oflag)
{
    MEDIA m;
    partition_map_header * map;
    DPME *data;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> default_number;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> number;
    <span class="enscript-type">long</span> size;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> multiple;

    m = open_pathname_as_media(name, oflag);
    <span class="enscript-keyword">if</span> (m == 0) {
	error(errno, <span class="enscript-string">&quot;can't open file '%s' for %sing&quot;</span>, name,
		(oflag == O_RDONLY)?<span class="enscript-string">&quot;read&quot;</span>:<span class="enscript-string">&quot;writ&quot;</span>);
	<span class="enscript-keyword">return</span> NULL;
    }

    map = (partition_map_header *) malloc(<span class="enscript-keyword">sizeof</span>(partition_map_header));
    <span class="enscript-keyword">if</span> (map == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for open partition map&quot;</span>);
	close_media(m);
	<span class="enscript-keyword">return</span> NULL;
    }
    map-&gt;name = name;
    map-&gt;writable = (oflag == O_RDONLY)?0:1;
    map-&gt;changed = 1;
    map-&gt;disk_order = NULL;
    map-&gt;base_order = NULL;

    <span class="enscript-keyword">if</span> (oldmap != NULL) {
	size = oldmap-&gt;physical_block;
    } <span class="enscript-keyword">else</span> {
	size = media_granularity(m);
    }
    m = open_deblock_media(PBLOCK_SIZE, m);
    map-&gt;m = m;
    <span class="enscript-keyword">if</span> (interactive) {
	printf(<span class="enscript-string">&quot;A physical block is %ld bytes: &quot;</span>, size);
	flush_to_newline(0);
	get_number_argument(<span class="enscript-string">&quot;what should be the physical block size? &quot;</span>,
		&amp;size, size);
	size = (size / PBLOCK_SIZE) * PBLOCK_SIZE;
	<span class="enscript-keyword">if</span> (size &lt; PBLOCK_SIZE) {
	    size = PBLOCK_SIZE;
	}
    }
    <span class="enscript-keyword">if</span> (map-&gt;physical_block &gt; MAXIOSIZE) {
	map-&gt;physical_block = MAXIOSIZE;
    }
    map-&gt;physical_block = size;
    <span class="enscript-comment">// printf(&quot;block size is %d\n&quot;, map-&gt;physical_block);
</span>
    <span class="enscript-keyword">if</span> (oldmap != NULL) {
	size = oldmap-&gt;logical_block;
    } <span class="enscript-keyword">else</span> {
	size = PBLOCK_SIZE;
    }
    <span class="enscript-keyword">if</span> (interactive) {
	printf(<span class="enscript-string">&quot;A logical block is %ld bytes: &quot;</span>, size);
	flush_to_newline(0);
	get_number_argument(<span class="enscript-string">&quot;what should be the logical block size? &quot;</span>,
		&amp;size, size);
	size = (size / PBLOCK_SIZE) * PBLOCK_SIZE;
	<span class="enscript-keyword">if</span> (size &lt; PBLOCK_SIZE) {
	    size = PBLOCK_SIZE;
	}
    }
#<span class="enscript-reference">if</span> 0
    <span class="enscript-keyword">if</span> (size &gt; map-&gt;physical_block) {
	size = map-&gt;physical_block;
    }
#<span class="enscript-reference">endif</span>
    map-&gt;logical_block = size;

    map-&gt;blocks_in_map = 0;
    map-&gt;maximum_in_map = -1;

    number = compute_device_size(map, oldmap);
    <span class="enscript-keyword">if</span> (interactive) {
	printf(<span class="enscript-string">&quot;size of 'device' is %lu blocks (%d byte blocks): &quot;</span>,
		number, map-&gt;logical_block);
	default_number = number;
	flush_to_newline(0);
	<span class="enscript-keyword">do</span> {
	    <span class="enscript-keyword">if</span> (get_number_argument(<span class="enscript-string">&quot;what should be the size? &quot;</span>, 
		    (<span class="enscript-type">long</span> *)&amp;number, default_number) == 0) {
		printf(<span class="enscript-string">&quot;Not a number\n&quot;</span>);
		flush_to_newline(1);
		number = 0;
	    } <span class="enscript-keyword">else</span> {
		multiple = get_multiplier(map-&gt;logical_block);
		<span class="enscript-keyword">if</span> (multiple == 0) {
		    printf(<span class="enscript-string">&quot;Bad multiplier\n&quot;</span>);
		    number = 0;
		} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (multiple != 1) {
		    <span class="enscript-keyword">if</span> (0xFFFFFFFF/multiple &lt; number) {
			printf(<span class="enscript-string">&quot;Number too large\n&quot;</span>);
			number = 0;
		    } <span class="enscript-keyword">else</span> {
			number *= multiple;
		    }
		}
	    }
	    default_number = kDefault;
	} <span class="enscript-keyword">while</span> (number == 0);

	<span class="enscript-keyword">if</span> (number &lt; 4) {
	    number = 4;
	}
	printf(<span class="enscript-string">&quot;new size of 'device' is %lu blocks (%d byte blocks)\n&quot;</span>,
		number, map-&gt;logical_block);
    }
    map-&gt;media_size = number;

    map-&gt;misc = (Block0 *) calloc(1, PBLOCK_SIZE);
    <span class="enscript-keyword">if</span> (map-&gt;misc == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for block zero buffer&quot;</span>);
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">// got it!
</span>	coerce_block0(map);
	sync_device_size(map);
	
	data = (DPME *) calloc(1, PBLOCK_SIZE);
	<span class="enscript-keyword">if</span> (data == NULL) {
	    error(errno, <span class="enscript-string">&quot;can't allocate memory for disk buffers&quot;</span>);
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-comment">// set data into entry
</span>	    data-&gt;dpme_signature = DPME_SIGNATURE;
	    data-&gt;dpme_map_entries = 1;
	    data-&gt;dpme_pblock_start = 1;
	    data-&gt;dpme_pblocks = map-&gt;media_size - 1;
	    strncpy(data-&gt;dpme_name, kFreeName, DPISTRLEN);
	    strncpy(data-&gt;dpme_type, kFreeType, DPISTRLEN);
	    data-&gt;dpme_lblock_start = 0;
	    data-&gt;dpme_lblocks = data-&gt;dpme_pblocks;
	    dpme_writable_set(data, 1);
	    dpme_readable_set(data, 1);
	    dpme_bootable_set(data, 0);
	    dpme_in_use_set(data, 0);
	    dpme_allocated_set(data, 0);
	    dpme_valid_set(data, 1);

	    <span class="enscript-keyword">if</span> (add_data_to_map(data, 1, map) == 0) {
		free(data);
	    } <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">return</span> map;
	    }
	}
    }
    close_partition_map(map);
    <span class="enscript-keyword">return</span> NULL;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">coerce_block0</span>(partition_map_header *map)
{
    Block0 *p;

    p = map-&gt;misc;
    <span class="enscript-keyword">if</span> (p == NULL) {
	<span class="enscript-keyword">return</span> 1;
    }
    <span class="enscript-keyword">if</span> (p-&gt;sbSig != BLOCK0_SIGNATURE) {
	p-&gt;sbSig = BLOCK0_SIGNATURE;
	<span class="enscript-keyword">if</span> (map-&gt;physical_block == 1) {
	    p-&gt;sbBlkSize = PBLOCK_SIZE;
	} <span class="enscript-keyword">else</span> {
	    p-&gt;sbBlkSize = map-&gt;physical_block;
	}
	p-&gt;sbBlkCount = 0;
	p-&gt;sbDevType = 0;
	p-&gt;sbDevId = 0;
	p-&gt;sbData = 0;
	p-&gt;sbDrvrCount = 0;
    }
    <span class="enscript-keyword">return</span> 0;	<span class="enscript-comment">// we do this simply to make it easier to call this function
</span>}


<span class="enscript-type">int</span>
<span class="enscript-function-name">add_partition_to_map</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dptype, u32 base, u32 length,
	partition_map_header *map)
{
    partition_map * cur;
    DPME *data;
    <span class="enscript-type">enum</span> add_action act;
    <span class="enscript-type">int</span> limit;
    u32 adjusted_base = 0;
    u32 adjusted_length = 0;
    u32 new_base = 0;
    u32 new_length = 0;

	<span class="enscript-comment">// find a block that starts includes base and length
</span>    cur = map-&gt;base_order;
    <span class="enscript-keyword">while</span> (cur != NULL) {
	<span class="enscript-keyword">if</span> (cur-&gt;data-&gt;dpme_pblock_start &lt;= base 
		&amp;&amp; (base + length) &lt;=
		    (cur-&gt;data-&gt;dpme_pblock_start + cur-&gt;data-&gt;dpme_pblocks)) {
	    <span class="enscript-keyword">break</span>;
	} <span class="enscript-keyword">else</span> {
	  <span class="enscript-comment">// check if request is past end of existing partitions, but on disk
</span>	  <span class="enscript-keyword">if</span> ((cur-&gt;next_by_base == NULL) &amp;&amp;
	      (base + length &lt;= map-&gt;media_size)) {
	    <span class="enscript-comment">// Expand final free partition
</span>	    <span class="enscript-keyword">if</span> ((istrncmp(cur-&gt;data-&gt;dpme_type, kFreeType, DPISTRLEN) == 0) &amp;&amp;
		base &gt;= cur-&gt;data-&gt;dpme_pblock_start) {
	      cur-&gt;data-&gt;dpme_pblocks =
		map-&gt;media_size - cur-&gt;data-&gt;dpme_pblock_start;
	      <span class="enscript-keyword">break</span>;
	    }
	    <span class="enscript-comment">// create an extra free partition
</span>	    <span class="enscript-keyword">if</span> (base &gt;= cur-&gt;data-&gt;dpme_pblock_start + cur-&gt;data-&gt;dpme_pblocks) {
	      <span class="enscript-keyword">if</span> (map-&gt;maximum_in_map &lt; 0) {
		limit = map-&gt;media_size;
	      } <span class="enscript-keyword">else</span> {
		limit = map-&gt;maximum_in_map;
	      }
	      <span class="enscript-keyword">if</span> (map-&gt;blocks_in_map + 1 &gt; limit) {
		printf(<span class="enscript-string">&quot;the map is not big enough\n&quot;</span>);
		<span class="enscript-keyword">return</span> 0;
	      }
	      data = create_data(kFreeName, kFreeType,
		  cur-&gt;data-&gt;dpme_pblock_start + cur-&gt;data-&gt;dpme_pblocks,
		  map-&gt;media_size - (cur-&gt;data-&gt;dpme_pblock_start + cur-&gt;data-&gt;dpme_pblocks));
	      <span class="enscript-keyword">if</span> (data != NULL) {
		<span class="enscript-keyword">if</span> (add_data_to_map(data, cur-&gt;disk_address, map) == 0) {
		  free(data);
		}
	      }
	    }
	  }
	  cur = cur-&gt;next_by_base;
	}
    }
	<span class="enscript-comment">// if it is not Extra then punt
</span>    <span class="enscript-keyword">if</span> (cur == NULL
	    || istrncmp(cur-&gt;data-&gt;dpme_type, kFreeType, DPISTRLEN) != 0) {
	printf(<span class="enscript-string">&quot;requested base and length is not &quot;</span>
		<span class="enscript-string">&quot;within an existing free partition\n&quot;</span>);
	<span class="enscript-keyword">return</span> 0;
    }
	<span class="enscript-comment">// figure out what to do and sizes
</span>    data = cur-&gt;data;
    <span class="enscript-keyword">if</span> (data-&gt;dpme_pblock_start == base) {
	<span class="enscript-comment">// replace or add
</span>	<span class="enscript-keyword">if</span> (data-&gt;dpme_pblocks == length) {
	    act = kReplace;
	} <span class="enscript-keyword">else</span> {
	    act = kAdd;
	    adjusted_base = base + length;
	    adjusted_length = data-&gt;dpme_pblocks - length;
	}
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">// split or add
</span>	<span class="enscript-keyword">if</span> (data-&gt;dpme_pblock_start + data-&gt;dpme_pblocks == base + length) {
	    act = kAdd;
	    adjusted_base = data-&gt;dpme_pblock_start;
	    adjusted_length = base - adjusted_base;
	} <span class="enscript-keyword">else</span> {
	    act = kSplit;
	    new_base = data-&gt;dpme_pblock_start;
	    new_length = base - new_base;
	    adjusted_base = base + length;
	    adjusted_length = data-&gt;dpme_pblocks - (length + new_length);
	}
    }
	<span class="enscript-comment">// if the map will overflow then punt
</span>    <span class="enscript-keyword">if</span> (map-&gt;maximum_in_map &lt; 0) {
	limit = map-&gt;media_size;
    } <span class="enscript-keyword">else</span> {
	limit = map-&gt;maximum_in_map;
    }
    <span class="enscript-keyword">if</span> (map-&gt;blocks_in_map + (<span class="enscript-type">int</span>)act &gt; limit) {
	printf(<span class="enscript-string">&quot;the map is not big enough\n&quot;</span>);
	<span class="enscript-keyword">return</span> 0;
    }

    data = create_data(name, dptype, base, length);
    <span class="enscript-keyword">if</span> (data == NULL) {
	<span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">if</span> (act == kReplace) {
	free(cur-&gt;data);
	cur-&gt;data = data;
    } <span class="enscript-keyword">else</span> {
	    <span class="enscript-comment">// adjust this block's size
</span>	cur-&gt;data-&gt;dpme_pblock_start = adjusted_base;
	cur-&gt;data-&gt;dpme_pblocks = adjusted_length;
	cur-&gt;data-&gt;dpme_lblocks = adjusted_length;
	    <span class="enscript-comment">// insert new with block address equal to this one
</span>	<span class="enscript-keyword">if</span> (add_data_to_map(data, cur-&gt;disk_address, map) == 0) {
	    free(data);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (act == kSplit) {
	    data = create_data(kFreeName, kFreeType, new_base, new_length);
	    <span class="enscript-keyword">if</span> (data != NULL) {
		    <span class="enscript-comment">// insert new with block address equal to this one
</span>		<span class="enscript-keyword">if</span> (add_data_to_map(data, cur-&gt;disk_address, map) == 0) {
		    free(data);
		}
	    }
	}
    }
	<span class="enscript-comment">// renumber disk addresses
</span>    renumber_disk_addresses(map);
	<span class="enscript-comment">// mark changed
</span>    map-&gt;changed = 1;
    <span class="enscript-keyword">return</span> 1;
}


DPME *
<span class="enscript-function-name">create_data</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name, <span class="enscript-type">const</span> <span class="enscript-type">char</span> *dptype, u32 base, u32 length)
{
    DPME *data;

    data = (DPME *) calloc(1, PBLOCK_SIZE);
    <span class="enscript-keyword">if</span> (data == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for disk buffers&quot;</span>);
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">// set data into entry
</span>	data-&gt;dpme_signature = DPME_SIGNATURE;
	data-&gt;dpme_map_entries = 1;
	data-&gt;dpme_pblock_start = base;
	data-&gt;dpme_pblocks = length;
	strncpy(data-&gt;dpme_name, name, DPISTRLEN);
	strncpy(data-&gt;dpme_type, dptype, DPISTRLEN);
	data-&gt;dpme_lblock_start = 0;
	data-&gt;dpme_lblocks = data-&gt;dpme_pblocks;
	dpme_init_flags(data);
    }
    <span class="enscript-keyword">return</span> data;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">dpme_init_flags</span>(DPME *data)
{
    <span class="enscript-keyword">if</span> (istrncmp(data-&gt;dpme_type, kHFSType, DPISTRLEN) == 0) { <span class="enscript-comment">/* XXX this is gross, fix it! */</span>
	data-&gt;dpme_flags = APPLE_HFS_FLAGS_VALUE;
    }
    <span class="enscript-keyword">else</span> {
	dpme_writable_set(data, 1);
	dpme_readable_set(data, 1);
	dpme_bootable_set(data, 0);
	dpme_in_use_set(data, 0);
	dpme_allocated_set(data, 1);
	dpme_valid_set(data, 1);
    }
}

<span class="enscript-comment">/* These bits are appropriate for Apple_UNIX_SVR2 partitions
 * used by NetBSD.  They may be ok for A/UX, but have not been
 * tested.
 */</span>
<span class="enscript-type">void</span>
<span class="enscript-function-name">bzb_init_slice</span>(BZB *bp, <span class="enscript-type">int</span> slice)
{
    memset(bp,0,<span class="enscript-keyword">sizeof</span>(BZB));
    <span class="enscript-keyword">if</span> ((slice &gt;= <span class="enscript-string">'A'</span>) &amp;&amp; (slice &lt;= <span class="enscript-string">'Z'</span>)) {
	slice += <span class="enscript-string">'a'</span> - <span class="enscript-string">'A'</span>;
    }
    <span class="enscript-keyword">if</span> ((slice != 0) &amp;&amp; ((slice &lt; <span class="enscript-string">'a'</span>) || (slice &gt; <span class="enscript-string">'z'</span>))) {
	error(-1,<span class="enscript-string">&quot;Bad bzb slice&quot;</span>);
	slice = 0;
    }
    <span class="enscript-keyword">switch</span> (slice) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
    <span class="enscript-keyword">case</span> <span class="enscript-string">'c'</span>:
	<span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-string">'a'</span>:
	bp-&gt;bzb_type = FST;
	strlcpy((<span class="enscript-type">char</span> *)bp-&gt;bzb_mount_point, <span class="enscript-string">&quot;/&quot;</span>, <span class="enscript-keyword">sizeof</span>(bp-&gt;bzb_mount_point));
	bp-&gt;bzb_inode = 1;
	bzb_root_set(bp,1);
	bzb_usr_set(bp,1);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-string">'b'</span>:
	bp-&gt;bzb_type = FSTSFS;
	strlcpy((<span class="enscript-type">char</span> *)bp-&gt;bzb_mount_point, <span class="enscript-string">&quot;(swap)&quot;</span>, <span class="enscript-keyword">sizeof</span>(bp-&gt;bzb_mount_point));
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-string">'g'</span>:
	strlcpy((<span class="enscript-type">char</span> *)bp-&gt;bzb_mount_point, <span class="enscript-string">&quot;/usr&quot;</span>, <span class="enscript-keyword">sizeof</span>(bp-&gt;bzb_mount_point));
	<span class="enscript-comment">/* Fall through */</span>
    <span class="enscript-reference">default</span>:
	bp-&gt;bzb_type = FST;
	bp-&gt;bzb_inode = 1;
	bzb_usr_set(bp,1);
	<span class="enscript-keyword">break</span>;
    }
    bzb_slice_set(bp,0);  <span class="enscript-comment">// XXX NetBSD disksubr.c ignores slice
</span>    <span class="enscript-comment">//	bzb_slice_set(bp,slice-'a'+1);
</span>    bp-&gt;bzb_magic = BZBMAGIC;
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">renumber_disk_addresses</span>(partition_map_header *map)
{
    partition_map * cur;
    <span class="enscript-type">long</span> ix;

	<span class="enscript-comment">// reset disk addresses
</span>    cur = map-&gt;disk_order;
    ix = 1;
    <span class="enscript-keyword">while</span> (cur != NULL) {
	cur-&gt;disk_address = ix++;
	cur-&gt;data-&gt;dpme_map_entries = map-&gt;blocks_in_map;
	cur = cur-&gt;next_on_disk;
    }
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">compute_device_size</span>(partition_map_header *map, partition_map_header *oldmap)
{
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">TEST_COMPUTE</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> length;
    <span class="enscript-type">struct</span> hd_geometry geometry;
    <span class="enscript-type">struct</span> stat info;
    loff_t pos;
#<span class="enscript-reference">endif</span>
    <span class="enscript-type">char</span>* data;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> l, r, x = 0;
    <span class="enscript-type">long</span> <span class="enscript-type">long</span> size;
    <span class="enscript-type">int</span> valid = 0;
#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">TEST_COMPUTE</span>
    <span class="enscript-type">int</span> fd;

    fd = map-&gt;fd-&gt;fd;
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    <span class="enscript-keyword">if</span> (fstat(fd, &amp;info) &lt; 0) {
	printf(<span class="enscript-string">&quot;stat of device failed\n&quot;</span>);
    } <span class="enscript-keyword">else</span> {
	printf(<span class="enscript-string">&quot;stat: mode = 0%o, type=%s\n&quot;</span>, info.st_mode, 
		(S_ISREG(info.st_mode)? <span class="enscript-string">&quot;Regular&quot;</span>:
		(S_ISBLK(info.st_mode)?<span class="enscript-string">&quot;Block&quot;</span>:<span class="enscript-string">&quot;Other&quot;</span>)));
	printf(<span class="enscript-string">&quot;size = %d, blocks = %d\n&quot;</span>,
		info.st_size, info.st_size/map-&gt;logical_block);
    }

    <span class="enscript-keyword">if</span> (ioctl(fd, BLKGETSIZE, &amp;length) &lt; 0) {
	printf(<span class="enscript-string">&quot;get device size failed\n&quot;</span>);
    } <span class="enscript-keyword">else</span> {
	printf(<span class="enscript-string">&quot;BLKGETSIZE:size in blocks = %u\n&quot;</span>, length);
    }

    <span class="enscript-keyword">if</span> (ioctl(fd, HDIO_GETGEO, &amp;geometry) &lt; 0) {
	printf(<span class="enscript-string">&quot;get device geometry failed\n&quot;</span>);
    } <span class="enscript-keyword">else</span> {
	printf(<span class="enscript-string">&quot;HDIO_GETGEO: heads=%d, sectors=%d, cylinders=%d, start=%d,  total=%d\n&quot;</span>,
		geometry.heads, geometry.sectors,
		geometry.cylinders, geometry.start,
		geometry.heads*geometry.sectors*geometry.cylinders);
    }

    <span class="enscript-keyword">if</span> ((pos = llseek(fd, (loff_t)0, SEEK_END)) &lt; 0) {
	printf(<span class="enscript-string">&quot;llseek to end of device failed\n&quot;</span>);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> ((pos = llseek(fd, (loff_t)0, SEEK_CUR)) &lt; 0) {
	printf(<span class="enscript-string">&quot;llseek to end of device failed on second try\n&quot;</span>);
    } <span class="enscript-keyword">else</span> {
	printf(<span class="enscript-string">&quot;llseek: pos = %d, blocks=%d\n&quot;</span>, pos, pos/map-&gt;logical_block);
    }
#<span class="enscript-reference">endif</span>

    <span class="enscript-keyword">if</span> (cflag == 0 &amp;&amp; oldmap != NULL &amp;&amp; oldmap-&gt;misc-&gt;sbBlkCount != 0) {
	<span class="enscript-keyword">return</span> (oldmap-&gt;misc-&gt;sbBlkCount
		* (oldmap-&gt;physical_block / map-&gt;logical_block));
    }

    size = media_total_size(map-&gt;m);
    <span class="enscript-keyword">if</span> (size != 0) {
    	<span class="enscript-keyword">return</span> (<span class="enscript-type">long</span>)(size / map-&gt;logical_block);
    }
 
    <span class="enscript-comment">// else case
</span> 
    data = (<span class="enscript-type">char</span> *) malloc(PBLOCK_SIZE);
    <span class="enscript-keyword">if</span> (data == NULL) {
	error(errno, <span class="enscript-string">&quot;can't allocate memory for try buffer&quot;</span>);
	x = 0;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">// double till off end
</span>	l = 0;
	r = 1024;
	<span class="enscript-keyword">while</span> (read_block(map, r, data) != 0) {
	    l = r;
	    <span class="enscript-keyword">if</span> (r &lt;= 1024) {
		r = r * 1024;
	    } <span class="enscript-keyword">else</span> {
		r = r * 2;
	    }
	    <span class="enscript-keyword">if</span> (r &gt;= 0x80000000) {
		r = 0xFFFFFFFE;
		<span class="enscript-keyword">break</span>;
	    }
	}
	<span class="enscript-comment">// binary search for end
</span>	<span class="enscript-keyword">while</span> (l &lt;= r) {
	    x = (r - l) / 2 + l;
	    <span class="enscript-keyword">if</span> ((valid = read_block(map, x, data)) != 0) {
		l = x + 1;
	    } <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (x &gt; 0) {
		    r = x - 1;
		} <span class="enscript-keyword">else</span> {
		    <span class="enscript-keyword">break</span>;
		}
	    }
	}
	<span class="enscript-keyword">if</span> (valid != 0) {
	    x = x + 1;
	}
	<span class="enscript-comment">// printf(&quot;size in blocks = %d\n&quot;, x);
</span>	free(data);
    }

    <span class="enscript-keyword">return</span> x;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">sync_device_size</span>(partition_map_header *map)
{
    Block0 *p;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> size;
    <span class="enscript-type">double</span> d;

    p = map-&gt;misc;
    <span class="enscript-keyword">if</span> (p == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    d = map-&gt;media_size;
    size = (d * map-&gt;logical_block) / p-&gt;sbBlkSize;
    <span class="enscript-keyword">if</span> (p-&gt;sbBlkCount != size) {
	p-&gt;sbBlkCount = size;
    }
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">delete_partition_from_map</span>(partition_map *entry)
{
    partition_map_header *map;
    DPME *data;

    <span class="enscript-keyword">if</span> (istrncmp(entry-&gt;data-&gt;dpme_type, kMapType, DPISTRLEN) == 0) {
	printf(<span class="enscript-string">&quot;Can't delete entry for the map itself\n&quot;</span>);
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (entry-&gt;contains_driver) {
	printf(<span class="enscript-string">&quot;This program can't install drivers\n&quot;</span>);
	<span class="enscript-keyword">if</span> (get_okay(<span class="enscript-string">&quot;are you sure you want to delete this driver? [n/y]: &quot;</span>, 0) != 1) {
	    <span class="enscript-keyword">return</span>;
	}
    }
    <span class="enscript-comment">// if past end of disk, delete it completely
</span>    <span class="enscript-keyword">if</span> (entry-&gt;next_by_base == NULL &amp;&amp;
	entry-&gt;data-&gt;dpme_pblock_start &gt;= entry-&gt;the_map-&gt;media_size) {
      <span class="enscript-keyword">if</span> (entry-&gt;contains_driver) {
	remove_driver(entry);	<span class="enscript-comment">// update block0 if necessary
</span>      }
      delete_entry(entry);
      <span class="enscript-keyword">return</span>;
    }
    <span class="enscript-comment">// If at end of disk, incorporate extra disk space to partition
</span>    <span class="enscript-keyword">if</span> (entry-&gt;next_by_base == NULL) {
      entry-&gt;data-&gt;dpme_pblocks =
	 entry-&gt;the_map-&gt;media_size - entry-&gt;data-&gt;dpme_pblock_start;
    }
    data = create_data(kFreeName, kFreeType,
	    entry-&gt;data-&gt;dpme_pblock_start, entry-&gt;data-&gt;dpme_pblocks);
    <span class="enscript-keyword">if</span> (data == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (entry-&gt;contains_driver) {
    	remove_driver(entry);	<span class="enscript-comment">// update block0 if necessary
</span>    }
    free(entry-&gt;data);
    free(entry-&gt;HFS_name);
    entry-&gt;HFS_kind = kHFS_not;
    entry-&gt;HFS_name = 0;
    entry-&gt;data = data;
    combine_entry(entry);
    map = entry-&gt;the_map;
    renumber_disk_addresses(map);
    map-&gt;changed = 1;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">contains_driver</span>(partition_map *entry)
{
    partition_map_header *map;
    Block0 *p;
    DDMap *m;
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> f;
    u32 start;

    map = entry-&gt;the_map;
    p = map-&gt;misc;
    <span class="enscript-keyword">if</span> (p == NULL) {
	<span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">if</span> (p-&gt;sbSig != BLOCK0_SIGNATURE) {
	<span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">if</span> (map-&gt;logical_block &gt; p-&gt;sbBlkSize) {
	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
	f = p-&gt;sbBlkSize / map-&gt;logical_block;
    }
    <span class="enscript-keyword">if</span> (p-&gt;sbDrvrCount &gt; 0) {
	m = (DDMap *) p-&gt;sbMap;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; p-&gt;sbDrvrCount; i++) {
	    start = get_align_long(&amp;m[i].ddBlock);
	    <span class="enscript-keyword">if</span> (entry-&gt;data-&gt;dpme_pblock_start &lt;= f*start
		    &amp;&amp; f*(start + m[i].ddSize)
			&lt;= (entry-&gt;data-&gt;dpme_pblock_start
			+ entry-&gt;data-&gt;dpme_pblocks)) {
		<span class="enscript-keyword">return</span> 1;
	    }
	}
    }
    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">combine_entry</span>(partition_map *entry)
{
    partition_map *p;
    u32 end;

    <span class="enscript-keyword">if</span> (entry == NULL
	    || istrncmp(entry-&gt;data-&gt;dpme_type, kFreeType, DPISTRLEN) != 0) {
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (entry-&gt;next_by_base != NULL) {
	p = entry-&gt;next_by_base;
	<span class="enscript-keyword">if</span> (istrncmp(p-&gt;data-&gt;dpme_type, kFreeType, DPISTRLEN) != 0) {
	    <span class="enscript-comment">// next is not free
</span>	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (entry-&gt;data-&gt;dpme_pblock_start + entry-&gt;data-&gt;dpme_pblocks
		!= p-&gt;data-&gt;dpme_pblock_start) {
	    <span class="enscript-comment">// next is not contiguous (XXX this is bad)
</span>	    printf(<span class="enscript-string">&quot;next entry is not contiguous\n&quot;</span>);
	    <span class="enscript-comment">// start is already minimum
</span>	    <span class="enscript-comment">// new end is maximum of two ends
</span>	    end = p-&gt;data-&gt;dpme_pblock_start + p-&gt;data-&gt;dpme_pblocks;
	    <span class="enscript-keyword">if</span> (end &gt; entry-&gt;data-&gt;dpme_pblock_start + entry-&gt;data-&gt;dpme_pblocks) {
	    	entry-&gt;data-&gt;dpme_pblocks = end - entry-&gt;data-&gt;dpme_pblock_start;
	    }
	    entry-&gt;data-&gt;dpme_lblocks = entry-&gt;data-&gt;dpme_pblocks;
	    delete_entry(p);
	} <span class="enscript-keyword">else</span> {
	    entry-&gt;data-&gt;dpme_pblocks += p-&gt;data-&gt;dpme_pblocks;
	    entry-&gt;data-&gt;dpme_lblocks = entry-&gt;data-&gt;dpme_pblocks;
	    delete_entry(p);
	}
    }
    <span class="enscript-keyword">if</span> (entry-&gt;prev_by_base != NULL) {
	p = entry-&gt;prev_by_base;
	<span class="enscript-keyword">if</span> (istrncmp(p-&gt;data-&gt;dpme_type, kFreeType, DPISTRLEN) != 0) {
	    <span class="enscript-comment">// previous is not free
</span>	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (p-&gt;data-&gt;dpme_pblock_start + p-&gt;data-&gt;dpme_pblocks
		!= entry-&gt;data-&gt;dpme_pblock_start) {
	    <span class="enscript-comment">// previous is not contiguous (XXX this is bad)
</span>	    printf(<span class="enscript-string">&quot;previous entry is not contiguous\n&quot;</span>);
	    <span class="enscript-comment">// new end is maximum of two ends
</span>	    end = p-&gt;data-&gt;dpme_pblock_start + p-&gt;data-&gt;dpme_pblocks;
	    <span class="enscript-keyword">if</span> (end &lt; entry-&gt;data-&gt;dpme_pblock_start + entry-&gt;data-&gt;dpme_pblocks) {
		end = entry-&gt;data-&gt;dpme_pblock_start + entry-&gt;data-&gt;dpme_pblocks;
	    }
	    entry-&gt;data-&gt;dpme_pblocks = end - p-&gt;data-&gt;dpme_pblock_start;
	    <span class="enscript-comment">// new start is previous entry's start
</span>	    entry-&gt;data-&gt;dpme_pblock_start = p-&gt;data-&gt;dpme_pblock_start;
	    entry-&gt;data-&gt;dpme_lblocks = entry-&gt;data-&gt;dpme_pblocks;
	    delete_entry(p);
	} <span class="enscript-keyword">else</span> {
	    entry-&gt;data-&gt;dpme_pblock_start = p-&gt;data-&gt;dpme_pblock_start;
	    entry-&gt;data-&gt;dpme_pblocks += p-&gt;data-&gt;dpme_pblocks;
	    entry-&gt;data-&gt;dpme_lblocks = entry-&gt;data-&gt;dpme_pblocks;
	    delete_entry(p);
	}
    }
    entry-&gt;contains_driver = contains_driver(entry);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">delete_entry</span>(partition_map *entry)
{
    partition_map_header *map;
    partition_map *p;

    map = entry-&gt;the_map;
    map-&gt;blocks_in_map--;

    remove_from_disk_order(entry);

    p = entry-&gt;next_by_base;
    <span class="enscript-keyword">if</span> (map-&gt;base_order == entry) {
	map-&gt;base_order = p;
    }
    <span class="enscript-keyword">if</span> (p != NULL) {
	p-&gt;prev_by_base = entry-&gt;prev_by_base;
    }
    <span class="enscript-keyword">if</span> (entry-&gt;prev_by_base != NULL) {
	entry-&gt;prev_by_base-&gt;next_by_base = p;
    }

    free(entry-&gt;data);
    free(entry-&gt;HFS_name);
    free(entry);
}


partition_map *
<span class="enscript-function-name">find_entry_by_disk_address</span>(<span class="enscript-type">long</span> ix, partition_map_header *map)
{
    partition_map * cur;

    cur = map-&gt;disk_order;
    <span class="enscript-keyword">while</span> (cur != NULL) {
	<span class="enscript-keyword">if</span> (cur-&gt;disk_address == ix) {
	    <span class="enscript-keyword">break</span>;
	}
	cur = cur-&gt;next_on_disk;
    }
    <span class="enscript-keyword">return</span> cur;
}


partition_map *
<span class="enscript-function-name">find_entry_by_type</span>(<span class="enscript-type">const</span> <span class="enscript-type">char</span> *type_name, partition_map_header *map)
{
    partition_map * cur;

    cur = map-&gt;base_order;
    <span class="enscript-keyword">while</span> (cur != NULL) {
	<span class="enscript-keyword">if</span> (istrncmp(cur-&gt;data-&gt;dpme_type, type_name, DPISTRLEN) == 0) {
	    <span class="enscript-keyword">break</span>;
	}
	cur = cur-&gt;next_by_base;
    }
    <span class="enscript-keyword">return</span> cur;
}

partition_map *
<span class="enscript-function-name">find_entry_by_base</span>(u32 base, partition_map_header *map)
{
    partition_map * cur;

    cur = map-&gt;base_order;
    <span class="enscript-keyword">while</span> (cur != NULL) {
	<span class="enscript-keyword">if</span> (cur-&gt;data-&gt;dpme_pblock_start == base) {
	    <span class="enscript-keyword">break</span>;
	}
	cur = cur-&gt;next_by_base;
    }
    <span class="enscript-keyword">return</span> cur;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">move_entry_in_map</span>(<span class="enscript-type">long</span> old_index, <span class="enscript-type">long</span> ix, partition_map_header *map)
{
    partition_map * cur;

    cur = find_entry_by_disk_address(old_index, map);
    <span class="enscript-keyword">if</span> (cur == NULL) {
	printf(<span class="enscript-string">&quot;No such partition\n&quot;</span>);
    } <span class="enscript-keyword">else</span> {
	remove_from_disk_order(cur);
	cur-&gt;disk_address = ix;
	insert_in_disk_order(cur);
	renumber_disk_addresses(map);
	map-&gt;changed = 1;
    }
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">remove_from_disk_order</span>(partition_map *entry)
{
    partition_map_header *map;
    partition_map *p;

    map = entry-&gt;the_map;
    p = entry-&gt;next_on_disk;
    <span class="enscript-keyword">if</span> (map-&gt;disk_order == entry) {
	map-&gt;disk_order = p;
    }
    <span class="enscript-keyword">if</span> (p != NULL) {
	p-&gt;prev_on_disk = entry-&gt;prev_on_disk;
    }
    <span class="enscript-keyword">if</span> (entry-&gt;prev_on_disk != NULL) {
	entry-&gt;prev_on_disk-&gt;next_on_disk = p;
    }
    entry-&gt;next_on_disk = NULL;
    entry-&gt;prev_on_disk = NULL;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">insert_in_disk_order</span>(partition_map *entry)
{
    partition_map_header *map;
    partition_map * cur;

    <span class="enscript-comment">// find position in disk list &amp; insert
</span>    map = entry-&gt;the_map;
    cur = map-&gt;disk_order;
    <span class="enscript-keyword">if</span> (cur == NULL || entry-&gt;disk_address &lt;= cur-&gt;disk_address) {
	map-&gt;disk_order = entry;
	entry-&gt;next_on_disk = cur;
	<span class="enscript-keyword">if</span> (cur != NULL) {
	    cur-&gt;prev_on_disk = entry;
	}
	entry-&gt;prev_on_disk = NULL;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">for</span> (cur = map-&gt;disk_order; cur != NULL; cur = cur-&gt;next_on_disk) {
	    <span class="enscript-keyword">if</span> (cur-&gt;disk_address &lt;= entry-&gt;disk_address
		    &amp;&amp; (cur-&gt;next_on_disk == NULL
		    || entry-&gt;disk_address &lt;= cur-&gt;next_on_disk-&gt;disk_address)) {
		entry-&gt;next_on_disk = cur-&gt;next_on_disk;
		cur-&gt;next_on_disk = entry;
		entry-&gt;prev_on_disk = cur;
		<span class="enscript-keyword">if</span> (entry-&gt;next_on_disk != NULL) {
		    entry-&gt;next_on_disk-&gt;prev_on_disk = entry;
		}
		<span class="enscript-keyword">break</span>;
	    }
	}
    }
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">insert_in_base_order</span>(partition_map *entry)
{
    partition_map_header *map;
    partition_map * cur;

    <span class="enscript-comment">// find position in base list &amp; insert
</span>    map = entry-&gt;the_map;
    cur = map-&gt;base_order;
    <span class="enscript-keyword">if</span> (cur == NULL
	    || entry-&gt;data-&gt;dpme_pblock_start &lt;= cur-&gt;data-&gt;dpme_pblock_start) {
	map-&gt;base_order = entry;
	entry-&gt;next_by_base = cur;
	<span class="enscript-keyword">if</span> (cur != NULL) {
	    cur-&gt;prev_by_base = entry;
	}
	entry-&gt;prev_by_base = NULL;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">for</span> (cur = map-&gt;base_order; cur != NULL; cur = cur-&gt;next_by_base) {
	    <span class="enscript-keyword">if</span> (cur-&gt;data-&gt;dpme_pblock_start &lt;= entry-&gt;data-&gt;dpme_pblock_start
		    &amp;&amp; (cur-&gt;next_by_base == NULL
		    || entry-&gt;data-&gt;dpme_pblock_start
			&lt;= cur-&gt;next_by_base-&gt;data-&gt;dpme_pblock_start)) {
		entry-&gt;next_by_base = cur-&gt;next_by_base;
		cur-&gt;next_by_base = entry;
		entry-&gt;prev_by_base = cur;
		<span class="enscript-keyword">if</span> (entry-&gt;next_by_base != NULL) {
		    entry-&gt;next_by_base-&gt;prev_by_base = entry;
		}
		<span class="enscript-keyword">break</span>;
	    }
	}
    }
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">resize_map</span>(<span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> new_size, partition_map_header *map)
{
    partition_map * entry;
    partition_map * next;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">int</span> incr;

    <span class="enscript-comment">// find map entry
</span>    entry = find_entry_by_type(kMapType, map);

    <span class="enscript-keyword">if</span> (entry == NULL) {
	printf(<span class="enscript-string">&quot;Couldn't find entry for map!\n&quot;</span>);
	<span class="enscript-keyword">return</span>;
    }
    next = entry-&gt;next_by_base;

	<span class="enscript-comment">// same size
</span>    <span class="enscript-keyword">if</span> (new_size == entry-&gt;data-&gt;dpme_pblocks) {
	<span class="enscript-comment">// do nothing
</span>	<span class="enscript-keyword">return</span>;
    }

	<span class="enscript-comment">// make it smaller
</span>    <span class="enscript-keyword">if</span> (new_size &lt; entry-&gt;data-&gt;dpme_pblocks) {
	<span class="enscript-keyword">if</span> (next == NULL
		|| istrncmp(next-&gt;data-&gt;dpme_type, kFreeType, DPISTRLEN) != 0) {
	    incr = 1;
	} <span class="enscript-keyword">else</span> {
	    incr = 0;
	}
	<span class="enscript-keyword">if</span> (new_size &lt; map-&gt;blocks_in_map + incr) {
	    printf(<span class="enscript-string">&quot;New size would be too small\n&quot;</span>);
	    <span class="enscript-keyword">return</span>;
	}
	<span class="enscript-keyword">goto</span> <span class="enscript-reference">doit</span>;
    }

	<span class="enscript-comment">// make it larger
</span>    <span class="enscript-keyword">if</span> (next == NULL
	    || istrncmp(next-&gt;data-&gt;dpme_type, kFreeType, DPISTRLEN) != 0) {
	printf(<span class="enscript-string">&quot;No free space to expand into\n&quot;</span>);
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (entry-&gt;data-&gt;dpme_pblock_start + entry-&gt;data-&gt;dpme_pblocks
	    != next-&gt;data-&gt;dpme_pblock_start) {
	printf(<span class="enscript-string">&quot;No contiguous free space to expand into\n&quot;</span>);
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (new_size &gt; entry-&gt;data-&gt;dpme_pblocks + next-&gt;data-&gt;dpme_pblocks) {
	printf(<span class="enscript-string">&quot;No enough free space\n&quot;</span>);
	<span class="enscript-keyword">return</span>;
    }
<span class="enscript-reference">doit</span>:
    entry-&gt;data-&gt;dpme_type[0] = 0;
    delete_partition_from_map(entry);
    add_partition_to_map(<span class="enscript-string">&quot;Apple&quot;</span>, kMapType, 1, new_size, map);
    map-&gt;maximum_in_map = new_size;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">remove_driver</span>(partition_map *entry)
{
    partition_map_header *map;
    Block0 *p;
    DDMap *m;
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> j;
    <span class="enscript-type">int</span> f;
    u32 start;

    map = entry-&gt;the_map;
    p = map-&gt;misc;
    <span class="enscript-keyword">if</span> (p == NULL) {
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (p-&gt;sbSig != BLOCK0_SIGNATURE) {
	<span class="enscript-keyword">return</span>;
    }
    <span class="enscript-keyword">if</span> (map-&gt;logical_block &gt; p-&gt;sbBlkSize) {
	<span class="enscript-comment">/* this is not supposed to happen, but let's just ignore it. */</span>
	<span class="enscript-keyword">return</span>;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/*
	 * compute the factor to convert the block numbers in block0
	 * into partition map block numbers.
	 */</span>
	f = p-&gt;sbBlkSize / map-&gt;logical_block;
    }
    <span class="enscript-keyword">if</span> (p-&gt;sbDrvrCount &gt; 0) {
	m = (DDMap *) p-&gt;sbMap;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; p-&gt;sbDrvrCount; i++) {
	    start = get_align_long(&amp;m[i].ddBlock);

	    <span class="enscript-comment">/* zap the driver if it is wholly contained in the partition */</span>
	    <span class="enscript-keyword">if</span> (entry-&gt;data-&gt;dpme_pblock_start &lt;= f*start
		    &amp;&amp; f*(start + m[i].ddSize)
			&lt;= (entry-&gt;data-&gt;dpme_pblock_start
			+ entry-&gt;data-&gt;dpme_pblocks)) {
		<span class="enscript-comment">// delete this driver
</span>		<span class="enscript-comment">// by copying down later ones and zapping the last
</span>		<span class="enscript-keyword">for</span> (j = i+1; j &lt; p-&gt;sbDrvrCount; j++, i++) {
		   put_align_long(get_align_long(&amp;m[j].ddBlock), &amp;m[i].ddBlock);
		   m[i].ddSize = m[j].ddSize;
		   m[i].ddType = m[j].ddType;
		}
	        put_align_long(0, &amp;m[i].ddBlock);
		m[i].ddSize = 0;
		m[i].ddType = 0;
		p-&gt;sbDrvrCount -= 1;
		<span class="enscript-keyword">return</span>; <span class="enscript-comment">/* XXX if we continue we will delete other drivers? */</span>
	    }
	}
    }
}

<span class="enscript-type">int</span>
<span class="enscript-function-name">read_block</span>(partition_map_header *map, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> num, <span class="enscript-type">char</span> *buf)
{
<span class="enscript-comment">//printf(&quot;read block %d\n&quot;, num);
</span>    <span class="enscript-keyword">return</span> read_media(map-&gt;m, ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>) num) * map-&gt;logical_block,
    		PBLOCK_SIZE, (<span class="enscript-type">void</span> *)buf);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">write_block</span>(partition_map_header *map, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> num, <span class="enscript-type">char</span> *buf)
{
    <span class="enscript-keyword">return</span> write_media(map-&gt;m, ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>) num) * map-&gt;logical_block,
    		PBLOCK_SIZE, (<span class="enscript-type">void</span> *)buf);
}
</pre>
<hr />
</body></html>