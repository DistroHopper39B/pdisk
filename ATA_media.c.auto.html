<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>ATA_media.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">ATA_media.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="ATA_media.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * ATA_media.c -
 *
 * Written by Eryk Vershen
 */</span>

<span class="enscript-comment">/*
 * Copyright 1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 */</span>


<span class="enscript-comment">// for printf()
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
<span class="enscript-comment">// for malloc() &amp; free()
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;ATA.h&gt;</span>
<span class="enscript-comment">// for SCSI command structures
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;MacSCSICommand.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;ATA_media.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;util.h&quot;</span>


<span class="enscript-comment">/*
 * Defines
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">RESULT_OFFSET</span>(type) \
    ((<span class="enscript-keyword">sizeof</span>(type) == 1) ? 3 : ((<span class="enscript-keyword">sizeof</span>(type) == 2) ? 1 : 0))
#<span class="enscript-reference">define</span> <span class="enscript-function-name">TBTrapTableAddress</span>(trapNum) (((trapNum &amp; 0x03FF) &lt;&lt; 2) + 0xE00)
#<span class="enscript-reference">define</span> <span class="enscript-function-name">SWAP_SHORTS</span>(x)  ((((x) &amp; 0xFFFF) &lt;&lt; 16) | (((x) &gt;&gt; 16) &amp; 0xFFFF))
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">LBA_CAPABLE</span> 0x0200


<span class="enscript-comment">/*
 * Types
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ATA_info *ATA_INFO;

<span class="enscript-type">struct</span> ATA_info {
    <span class="enscript-type">long</span>	    lba;
    <span class="enscript-type">long</span>	    heads;
    <span class="enscript-type">long</span>	    sectors;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ATA_media *ATA_MEDIA;

<span class="enscript-type">struct</span> ATA_media {
    <span class="enscript-type">struct</span> media    m;
    <span class="enscript-type">long</span>            id;
    <span class="enscript-type">struct</span> ATA_info info;
};

<span class="enscript-type">struct</span> ATA_manager {
    <span class="enscript-type">long</span>        exists;
    <span class="enscript-type">long</span>        kind;
    <span class="enscript-type">struct</span> {
	<span class="enscript-type">char</span>    major;
	<span class="enscript-type">char</span>    minor;
    } version;
    <span class="enscript-type">short</span>       busCount;
    <span class="enscript-type">long</span>	*bus_list;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ATA_media_iterator *ATA_MEDIA_ITERATOR;

<span class="enscript-type">struct</span> ATA_media_iterator {
    <span class="enscript-type">struct</span> media_iterator   m;
    <span class="enscript-type">long</span>                    bus_index;
    <span class="enscript-type">long</span>                    bus;
    <span class="enscript-type">long</span>                    id;
};

<span class="enscript-type">struct</span> ATA_identify_drive_info {        <span class="enscript-comment">/* word */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  config_bits;        <span class="enscript-comment">/*  0 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  num_cylinders;      <span class="enscript-comment">/*  1 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved2;          <span class="enscript-comment">/*  2 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  num_heads;          <span class="enscript-comment">/*  3 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  bytes_per_track;    <span class="enscript-comment">/*  4 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  bytes_per_sector;   <span class="enscript-comment">/*  5 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  sectors_per_track;  <span class="enscript-comment">/*  6 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  vendor7[3];         <span class="enscript-comment">/*  7-9 */</span>
    <span class="enscript-type">char</span>            serial_number[20];  <span class="enscript-comment">/* 10-19 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  buffer_type;        <span class="enscript-comment">/* 20 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  buffer_size;        <span class="enscript-comment">/* 21 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  num_of_ecc_bytes;   <span class="enscript-comment">/* 22 */</span>
    <span class="enscript-type">char</span>            firmware_rev[8];    <span class="enscript-comment">/* 23-26 */</span>
    <span class="enscript-type">char</span>            model_number[40];   <span class="enscript-comment">/* 27-46 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  word47;             <span class="enscript-comment">/* 47 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  double_word_io;     <span class="enscript-comment">/* 48 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  capabilities;       <span class="enscript-comment">/* 49 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved50;         <span class="enscript-comment">/* 50 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  pio_timing;         <span class="enscript-comment">/* 51 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  dma_timing;         <span class="enscript-comment">/* 52 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  current_is_valid;   <span class="enscript-comment">/* 53 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  cur_cylinders;      <span class="enscript-comment">/* 54 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  cur_heads;          <span class="enscript-comment">/* 55 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  cur_sec_per_track;  <span class="enscript-comment">/* 56 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   total_sectors;      <span class="enscript-comment">/* 57-58 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  multiple_sectors;   <span class="enscript-comment">/* 59 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span>   lba_sectors;        <span class="enscript-comment">/* 60-61 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  singleword_dma;     <span class="enscript-comment">/* 62 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  multiword_dma;      <span class="enscript-comment">/* 63 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved64[64];     <span class="enscript-comment">/* 64-127 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  vendor128[32];      <span class="enscript-comment">/* 128-159 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved160[96];    <span class="enscript-comment">/* 160-255 */</span>
};

<span class="enscript-type">struct</span> ATAPI_identify_drive_info {      <span class="enscript-comment">/* word */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  config_bits;        <span class="enscript-comment">/*  0 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  retired1[9];        <span class="enscript-comment">/*  1-9 */</span>
    <span class="enscript-type">char</span>            serial_number[20];  <span class="enscript-comment">/* 10-19 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  retired20[3];       <span class="enscript-comment">/* 20-22 */</span>
    <span class="enscript-type">char</span>            firmware_rev[8];    <span class="enscript-comment">/* 23-26 */</span>
    <span class="enscript-type">char</span>            model_number[40];   <span class="enscript-comment">/* 27-46 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  retired47[2];       <span class="enscript-comment">/* 47-48 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  capabilities;       <span class="enscript-comment">/* 49 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved50;         <span class="enscript-comment">/* 50 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  pio_timing;         <span class="enscript-comment">/* 51 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  dma_timing;         <span class="enscript-comment">/* 52 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  current_is_valid;   <span class="enscript-comment">/* 53 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  retired54[8];       <span class="enscript-comment">/* 54-61 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  singleword_dma;     <span class="enscript-comment">/* 62 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  multiword_dma;      <span class="enscript-comment">/* 63 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  pio_transfer;       <span class="enscript-comment">/* 64 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  min_cycle_time;     <span class="enscript-comment">/* 65 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  rec_cycle_time;     <span class="enscript-comment">/* 66 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  min_wo_flow;        <span class="enscript-comment">/* 67 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  min_with_flow;      <span class="enscript-comment">/* 68 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved69[2];      <span class="enscript-comment">/* 69-70 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  release_over;       <span class="enscript-comment">/* 71 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  release_service;    <span class="enscript-comment">/* 72 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  major_rev;          <span class="enscript-comment">/* 73 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  minor_rev;          <span class="enscript-comment">/* 74 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved75[53];     <span class="enscript-comment">/* 75-127 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  vendor128[32];      <span class="enscript-comment">/* 128-159 */</span>
    <span class="enscript-type">unsigned</span> <span class="enscript-type">short</span>  reserved160[96];    <span class="enscript-comment">/* 160-255 */</span>
};

<span class="enscript-comment">/* Identifies the bus protocol type. */</span>
<span class="enscript-type">enum</span> {
    kDevUnknown     =   0,
    kDevATA         =   1,
    kDevATAPI       =   2,
    kDevPCMCIA      =   3
};


<span class="enscript-comment">/*
 * Global Constants
 */</span>
<span class="enscript-type">enum</span> {
    kNoDevice = 0x00FF,
    kATAtimeout = 3000,
    kATAcmdATAPIPacket          = 0x00A0                        <span class="enscript-comment">/* ATAPI packet command */</span>
};


<span class="enscript-comment">/*
 * Global Variables
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">long</span> ata_inited = 0;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> ATA_manager ata_mgr;

<span class="enscript-comment">/*
 * Forward declarations
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">ATAManagerPresent</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">ATAHardwarePresent</span>(<span class="enscript-type">void</span>);
pascal SInt16 <span class="enscript-function-name">ataManager</span>(ataPB *pb);
<span class="enscript-type">void</span> <span class="enscript-function-name">ata_init</span>(<span class="enscript-type">void</span>);
ATA_MEDIA <span class="enscript-function-name">new_ata_media</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">long</span> <span class="enscript-function-name">read_ata_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address);
<span class="enscript-type">long</span> <span class="enscript-function-name">write_ata_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address);
<span class="enscript-type">long</span> <span class="enscript-function-name">close_ata_media</span>(MEDIA m);
<span class="enscript-type">long</span> <span class="enscript-function-name">os_reload_ata_media</span>(MEDIA m);
<span class="enscript-type">long</span> <span class="enscript-function-name">compute_id</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> device);
pascal SInt16 <span class="enscript-function-name">ataManager</span>(ataPB *pb);
<span class="enscript-type">int</span> <span class="enscript-function-name">ATA_ReadBlock</span>(UInt32 deviceID, ATA_INFO info, UInt32 block_size, UInt32 block, UInt8 *address);
<span class="enscript-type">int</span> <span class="enscript-function-name">ATA_WriteBlock</span>(UInt32 deviceID, ATA_INFO info, UInt32 block_size, UInt32 block, UInt8 *address);
<span class="enscript-type">long</span> <span class="enscript-function-name">get_info</span>(<span class="enscript-type">long</span> id, <span class="enscript-type">struct</span> ATA_identify_drive_info *ip);
<span class="enscript-type">long</span> <span class="enscript-function-name">get_pi_info</span>(<span class="enscript-type">long</span> id, <span class="enscript-type">struct</span> ATAPI_identify_drive_info *ip);
<span class="enscript-type">long</span> <span class="enscript-function-name">is_atapi</span>(<span class="enscript-type">long</span> id);
<span class="enscript-type">long</span> <span class="enscript-function-name">read_atapi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address);
<span class="enscript-type">long</span> <span class="enscript-function-name">write_atapi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address);
<span class="enscript-type">int</span> <span class="enscript-function-name">ATAPI_ReadBlock</span>(UInt32 deviceID, UInt32 block_size, UInt32 block, UInt8 *address);
<span class="enscript-type">int</span> <span class="enscript-function-name">ATAPI_TestUnitReady</span>(UInt32 deviceID);
<span class="enscript-type">int</span> <span class="enscript-function-name">ATAPI_ReadCapacity</span>(UInt32 deviceID, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *block_size, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *blocks);
ATA_MEDIA_ITERATOR <span class="enscript-function-name">new_ata_iterator</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">reset_ata_iterator</span>(MEDIA_ITERATOR m);
<span class="enscript-type">char</span> *<span class="enscript-function-name">step_ata_iterator</span>(MEDIA_ITERATOR m);
<span class="enscript-type">void</span> <span class="enscript-function-name">delete_ata_iterator</span>(MEDIA_ITERATOR m);
<span class="enscript-type">int</span> <span class="enscript-function-name">ata_bus_present</span>(<span class="enscript-type">int</span> num);


<span class="enscript-comment">/*
 * Routines
 */</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">GENERATINGPOWERPC</span>
pascal SInt16
<span class="enscript-function-name">ataManager</span>(ataPB *pb)
{
    #ifdef applec
	#<span class="enscript-keyword">if</span> <span class="enscript-keyword">sizeof</span>(SInt16) &gt; 4
	    #error <span class="enscript-string">&quot;Result types larger than 4 bytes are not supported.&quot;</span>
	#endif
    #endif
    <span class="enscript-type">long</span>    private_result;

    private_result = CallUniversalProc(
	*(UniversalProcPtr*)TBTrapTableAddress(0xAAF1),
	kPascalStackBased
	 | RESULT_SIZE(SIZE_CODE(<span class="enscript-keyword">sizeof</span>(SInt16)))
	 | STACK_ROUTINE_PARAMETER(1, SIZE_CODE(<span class="enscript-keyword">sizeof</span>(pb))),
	pb);
    <span class="enscript-keyword">return</span> *(((SInt16*)&amp;private_result) + RESULT_OFFSET(SInt16));
}
#<span class="enscript-reference">endif</span>


<span class="enscript-type">int</span>
<span class="enscript-function-name">ATAHardwarePresent</span>(<span class="enscript-type">void</span>)
{
    UInt16  configFlags;

    <span class="enscript-comment">// Hardware configuration flags
</span>    configFlags = LMGetHWCfgFlags();
    
    <span class="enscript-keyword">return</span> ((configFlags &amp; 0x0080) != 0);
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ATAManagerPresent</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">if</span> (ATAHardwarePresent()) {
	<span class="enscript-keyword">return</span> (TrapAvailable(kATATrap));
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">return</span> 0;
    }
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">ata_init</span>(<span class="enscript-type">void</span>)
{
    ataMgrInquiry   pb;
    OSErr           status;
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> j;

    <span class="enscript-keyword">if</span> (ata_inited != 0) {
	<span class="enscript-keyword">return</span>;
    }
    ata_inited = 1;
    
    <span class="enscript-keyword">if</span> (ATAManagerPresent() == 0) {
	ata_mgr.exists = 0;
	<span class="enscript-keyword">return</span>;
    }

    ata_mgr.exists = 1;
    ata_mgr.kind = allocate_media_kind();

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    
    pb.ataPBFunctionCode =  kATAMgrManagerInquiry;
    pb.ataPBVers =          kATAPBVers1;

    status = ataManager((ataPB*) &amp;pb );
    
    <span class="enscript-keyword">if</span> (status != noErr) {
	ata_mgr.exists = 0;
	<span class="enscript-keyword">return</span>;
    }
    ata_mgr.version.major = pb.ataMgrVersion.majorRev;
    ata_mgr.version.minor = pb.ataMgrVersion.minorAndBugRev &gt;&gt; 4;
    ata_mgr.busCount = pb.ataBusCnt;

    ata_mgr.bus_list = (<span class="enscript-type">long</span> *) calloc(ata_mgr.busCount, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">long</span>));
    <span class="enscript-keyword">if</span> (ata_mgr.bus_list == 0) {
	ata_mgr.busCount = 0;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">for</span> (i = 0, j = 0; j &lt; ata_mgr.busCount; i++) {
	    <span class="enscript-keyword">if</span> (ata_bus_present(i)) {
		ata_mgr.bus_list[j] = i;
		j++;
	    }
	}
    }
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ata_bus_present</span>(<span class="enscript-type">int</span> num)
{
    ataBusInquiry   pb;
    OSErr           status;

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    
    pb.ataPBFunctionCode =  kATAMgrBusInquiry;
    pb.ataPBVers =          kATAPBVers1;
    pb.ataPBDeviceID =	    num;

    status = ataManager((ataPB*) &amp;pb );
    
    <span class="enscript-keyword">if</span> (status == noErr) {
	<span class="enscript-keyword">return</span> 1;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">//printf(&quot;status = %d\n&quot;, status);
</span>	<span class="enscript-keyword">return</span> 0;
    }
}


ATA_MEDIA
<span class="enscript-function-name">new_ata_media</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (ATA_MEDIA) new_media(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ATA_media));
}


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -


<span class="enscript-type">long</span>
<span class="enscript-function-name">compute_id</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> device)
{
    <span class="enscript-type">long</span> id;
    <span class="enscript-type">int</span> i;
    
    id = -1;
    <span class="enscript-keyword">for</span> (i = 0; i &lt; ata_mgr.busCount; i++) {
	<span class="enscript-keyword">if</span> (bus == ata_mgr.bus_list[i]) {
	    <span class="enscript-keyword">break</span>;
	}
    }
    <span class="enscript-keyword">if</span> (i &gt;= ata_mgr.busCount) {
	<span class="enscript-comment">/* bad bus id */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ata_mgr.version.major &lt; 3) {
	<span class="enscript-keyword">if</span> (device != 0) {
	    <span class="enscript-comment">/* bad device id */</span>
	} <span class="enscript-keyword">else</span> {
	    id = bus &amp; 0xFF;
	}
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">if</span> (device &lt; 0 || device &gt; 1) {
	    <span class="enscript-comment">/* bad device id */</span>
	} <span class="enscript-keyword">else</span> {
	    id = ((device &amp; 0xFF) &lt;&lt; 8) | (bus &amp; 0xFF);
	}
    }
    <span class="enscript-keyword">return</span> id;
}


<span class="enscript-type">static</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">get_info</span>(<span class="enscript-type">long</span> id, <span class="enscript-type">struct</span> ATA_identify_drive_info *ip)
{
    ataIdentify     pb;
    ataDevConfiguration pb2;
    OSErr           status;
    <span class="enscript-type">long</span>            rtn_value;
    <span class="enscript-type">long</span>            atapi;

    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ATA_identify_drive_info) &lt; 512) {
	<span class="enscript-keyword">return</span> 0;
    }
    clear_memory((<span class="enscript-type">void</span> *)ip, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ATA_identify_drive_info));

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    pb.ataPBFunctionCode    =   kATAMgrDriveIdentify;
    pb.ataPBVers            =   kATAPBVers1;
    pb.ataPBDeviceID        =   id;
    pb.ataPBFlags           =   mATAFlagIORead | mATAFlagByteSwap;
    pb.ataPBTimeOut         =   kATAtimeout;
    pb.ataPBBuffer          =   (<span class="enscript-type">void</span>*) ip;
    
    status = ataManager((ataPB*) &amp;pb );

    <span class="enscript-keyword">if</span> (status != noErr) {
	<span class="enscript-comment">//printf(&quot;get info status = %d\n&quot;, status);
</span>	rtn_value = 0;
    } <span class="enscript-keyword">else</span> {
	ip-&gt;total_sectors = SWAP_SHORTS(ip-&gt;total_sectors);
	ip-&gt;lba_sectors = SWAP_SHORTS(ip-&gt;lba_sectors);
	rtn_value = 1;
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">static</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">is_atapi</span>(<span class="enscript-type">long</span> id)
{
    ataDevConfiguration pb;
    OSErr           status;
    <span class="enscript-type">long</span>            atapi;

    atapi = 0;
    <span class="enscript-keyword">if</span> (ata_mgr.version.major &gt;= 2) {
	clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
	pb.ataPBFunctionCode    =   kATAMgrGetDrvConfiguration;
	pb.ataPBVers            =   kATAPBVers2;
	pb.ataPBDeviceID        =   id;
	pb.ataPBTimeOut     =   kATAtimeout;
	
	status = ataManager((ataPB*) &amp;pb );
	<span class="enscript-keyword">if</span> (status != noErr) {
	    <span class="enscript-comment">//printf(&quot;is atatpi status = %d\n&quot;, status);
</span>	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pb.ataDeviceType == kDevATAPI) {
	    atapi = 1;
	    <span class="enscript-comment">/* the drive can be asleep or something in which case this doesn't work */</span>
	    <span class="enscript-comment">/* how do we do reads */</span>
	}
    }
    <span class="enscript-keyword">return</span> atapi;
}


MEDIA
<span class="enscript-function-name">open_ata_as_media</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> device)
{
    ATA_MEDIA   a;
    <span class="enscript-type">long</span>        id;
    <span class="enscript-type">struct</span> ATA_identify_drive_info  info;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buf;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> total;
    
    <span class="enscript-keyword">if</span> (ata_inited == 0) {
	ata_init();
    }
    
    <span class="enscript-keyword">if</span> (ata_mgr.exists == 0) {
	<span class="enscript-comment">//printf(&quot;ATA manager does not exist\n&quot;);
</span>	<span class="enscript-keyword">return</span> 0;
    }

    id = compute_id(bus, device);

    <span class="enscript-keyword">if</span> (id &lt; 0) {
    	<span class="enscript-keyword">return</span> 0;

    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (is_atapi(id)) {
	a = (ATA_MEDIA) open_atapi_as_media(bus, device);

    } <span class="enscript-keyword">else</span> {
	a = 0;
	<span class="enscript-keyword">if</span> (get_info(id, &amp;info) != 0) {
	    a = new_ata_media();
	    <span class="enscript-keyword">if</span> (a != 0) {
		a-&gt;m.kind = ata_mgr.kind;
		<span class="enscript-keyword">if</span> ((info.capabilities &amp; LBA_CAPABLE) != 0) {
		    total = info.lba_sectors;
		    a-&gt;info.lba = 1;
		    a-&gt;info.heads = 0;
		    a-&gt;info.sectors = 0;
		} <span class="enscript-keyword">else</span> {
		    <span class="enscript-comment">/* Only CHS - Cylinder Head Sector addressing */</span>
		    total = info.total_sectors;
		    a-&gt;info.lba = 0;
		    a-&gt;info.heads = info.cur_heads;
		    a-&gt;info.sectors = info.cur_sec_per_track;
		}
		{ <span class="enscript-comment">/* XXX this should be a loop in a subroutine */</span>
		    buf = malloc(2048);
		    <span class="enscript-keyword">if</span> (ATA_ReadBlock(id, &amp;a-&gt;info, 512, 0, buf)) {
			a-&gt;m.grain = 512;
		    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ATA_ReadBlock(id, &amp;a-&gt;info, 1024, 0, buf)) {
			a-&gt;m.grain = 1024;
		    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (ATA_ReadBlock(id, &amp;a-&gt;info, 2048, 0, buf)) {
			a-&gt;m.grain = 2048;
		    } <span class="enscript-keyword">else</span> {
			a-&gt;m.grain = 512; <span class="enscript-comment">/* XXX should really return failure here */</span>
		    }
		    free(buf);
		}
		<span class="enscript-keyword">if</span> (total == 0) {
		    a-&gt;m.size_in_bytes = ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)1000) * a-&gt;m.grain; <span class="enscript-comment">/* XXX not right */</span>
		} <span class="enscript-keyword">else</span> {
		    a-&gt;m.size_in_bytes = ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)total) * a-&gt;m.grain;
		}
		a-&gt;m.do_read = read_ata_media;
		a-&gt;m.do_write = write_ata_media;
		a-&gt;m.do_close = close_ata_media;
		a-&gt;m.do_os_reload = os_reload_ata_media;
		a-&gt;id = id;
	    }
	} <span class="enscript-keyword">else</span> {
	    printf(<span class="enscript-string">&quot;ATA - couldn't get info\n&quot;</span>);
	}
    }
    <span class="enscript-keyword">return</span> (MEDIA) a;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">read_ata_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address)
{
    ATA_MEDIA a;
    ataIOPB pb;
    OSErr       status;
    <span class="enscript-type">long</span> rtn_value;
    <span class="enscript-type">long</span> block;
    <span class="enscript-type">long</span> block_count;
    <span class="enscript-type">long</span> block_size;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer;
    <span class="enscript-type">int</span> i;
    
    a = (ATA_MEDIA) m;
    rtn_value = 0;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != ata_mgr.kind) {
	<span class="enscript-comment">/* wrong kind - XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (count &lt;= 0 || count % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle size */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset &lt; 0 || offset % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle offset */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset + count &gt; a-&gt;m.size_in_bytes) {
	<span class="enscript-comment">/* check for offset (and offset+count) too large */</span>
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* do a read on the physical device */</span>
	block_size = a-&gt;m.grain;
	block = offset / block_size;
	block_count = count / block_size;
	buffer = address;
	rtn_value = 1;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; block_count; i++) {
	    <span class="enscript-keyword">if</span> (ATA_ReadBlock(a-&gt;id, &amp;a-&gt;info, block_size, block, buffer) == 0) {
		rtn_value = 0;
		<span class="enscript-keyword">break</span>;
	    }
	    buffer += block_size;
	    block += 1;
	}
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">write_ata_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address)
{
    ATA_MEDIA a;
    <span class="enscript-type">long</span> rtn_value;
    <span class="enscript-type">long</span> block;
    <span class="enscript-type">long</span> block_count;
    <span class="enscript-type">long</span> block_size;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer;
    <span class="enscript-type">int</span> i;
    
    a = (ATA_MEDIA) m;
    rtn_value = 0;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != ata_mgr.kind) {
	<span class="enscript-comment">/* XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (count &lt;= 0 || count % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle size */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset &lt; 0 || offset % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle offset */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset + count &gt; a-&gt;m.size_in_bytes) {
	<span class="enscript-comment">/* check for offset (and offset+count) too large */</span>
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* do a write on the physical device */</span>
	block_size = a-&gt;m.grain;
	block = offset / block_size;
	block_count = count / block_size;
	buffer = address;
	rtn_value = 1;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; block_count; i++) {
	    <span class="enscript-keyword">if</span> (ATA_WriteBlock(a-&gt;id, &amp;a-&gt;info, block_size, block, buffer) == 0) {
		rtn_value = 0;
		<span class="enscript-keyword">break</span>;
	    }
	    buffer += block_size;
	    block += 1;
	}
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">close_ata_media</span>(MEDIA m)
{
    ATA_MEDIA a;
    
    a = (ATA_MEDIA) m;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != ata_mgr.kind) {
	<span class="enscript-comment">/* XXX need to error here - this is an internal problem */</span>
	<span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-comment">/* XXX nothing to do - I think? */</span>
    <span class="enscript-keyword">return</span> 1;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">os_reload_ata_media</span>(MEDIA m)
{
    printf(<span class="enscript-string">&quot;Reboot your system so the partition table will be reread.\n&quot;</span>);
    <span class="enscript-keyword">return</span> 1;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ATA_ReadBlock</span>(UInt32 deviceID, ATA_INFO info, UInt32 block_size, UInt32 block, UInt8 *address)
{
    ataIOPB     pb;
    OSErr       status;
    <span class="enscript-type">long</span>        slave;
    <span class="enscript-type">long</span>	lba, cyl, head, sector;

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    pb.ataPBFunctionCode    =   kATAMgrExecIO;
    pb.ataPBVers            =   kATAPBVers1;
    pb.ataPBDeviceID        =   deviceID;
    pb.ataPBFlags           =   mATAFlagTFRead | mATAFlagIORead ;
    pb.ataPBTimeOut         =   kATAtimeout;
    
    pb.ataPBLogicalBlockSize =  block_size;
    pb.ataPBBuffer          =   address;
    pb.ataPBByteCount = block_size;
    <span class="enscript-keyword">if</span> (info-&gt;lba) {
    	lba = 0x40;
    	sector = block &amp; 0xFF;
    	head = (block &gt;&gt; 24) &amp; 0xF;
    	cyl = (block &gt;&gt; 8) &amp; 0xFFFF;
    } <span class="enscript-keyword">else</span> {
    	lba = 0x00;
	sector = (block % info-&gt;sectors) + 1;
	cyl = block / info-&gt;sectors;
	head = cyl % info-&gt;heads;
	cyl = cyl / info-&gt;heads;
    }

    pb.ataPBTaskFile.ataTFCount = 1;
    pb.ataPBTaskFile.ataTFSector = sector;
    pb.ataPBTaskFile.ataTFCylinder = cyl;
    <span class="enscript-keyword">if</span> (deviceID &amp; 0x0FF00) {
	slave = 0x10;
    } <span class="enscript-keyword">else</span> {
	slave = 0x0;
    }
			      <span class="enscript-comment">/* std | L/C  | Drive | head */</span>
    pb.ataPBTaskFile.ataTFSDH = 0xA0 | lba | slave | head;
    pb.ataPBTaskFile.ataTFCommand = kATAcmdRead;

    status = ataManager((ataPB*) &amp;pb );
    <span class="enscript-keyword">if</span> (status != noErr) {
	<span class="enscript-comment">/* failure */</span>
	<span class="enscript-comment">//printf(&quot; ATA read status = %d\n&quot;, status);
</span>	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">return</span> 1;
    }
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ATA_WriteBlock</span>(UInt32 deviceID, ATA_INFO info, UInt32 block_size, UInt32 block, UInt8 *address)
{
    ataIOPB     pb;
    OSErr       status;
    <span class="enscript-type">long</span>        slave;
    <span class="enscript-type">long</span>	lba, cyl, head, sector;

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    pb.ataPBFunctionCode    =   kATAMgrExecIO;
    pb.ataPBVers            =   kATAPBVers1;
    pb.ataPBDeviceID        =   deviceID;
    pb.ataPBFlags           =   mATAFlagTFRead | mATAFlagIOWrite ;
    pb.ataPBTimeOut         =   kATAtimeout;
    
    pb.ataPBLogicalBlockSize =  block_size;
    pb.ataPBBuffer          =   address;
    pb.ataPBByteCount = block_size;
    <span class="enscript-keyword">if</span> (info-&gt;lba) {
    	lba = 0x40;
    	sector = block &amp; 0xFF;
    	head = (block &gt;&gt; 24) &amp; 0xF;
    	cyl = (block &gt;&gt; 8) &amp; 0xFFFF;
    } <span class="enscript-keyword">else</span> {
    	lba = 0x00;
	sector = (block % info-&gt;sectors) + 1;
	cyl = block / info-&gt;sectors;
	head = cyl % info-&gt;heads;
	cyl = cyl / info-&gt;heads;
    }
    pb.ataPBTaskFile.ataTFCount = 1;
    pb.ataPBTaskFile.ataTFSector = sector;
    pb.ataPBTaskFile.ataTFCylinder = cyl;
    <span class="enscript-keyword">if</span> (deviceID &amp; 0x0FF00) {
	slave = 0x10;
    } <span class="enscript-keyword">else</span> {
	slave = 0x0;
    }
			      <span class="enscript-comment">/* std | L/C  | Drive | head */</span>
    pb.ataPBTaskFile.ataTFSDH = 0xA0 | lba | slave | head;
    pb.ataPBTaskFile.ataTFCommand = kATAcmdWrite;

    status = ataManager((ataPB*) &amp;pb );
    <span class="enscript-keyword">if</span> (status != noErr) {
	<span class="enscript-comment">/* failure */</span>
	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">return</span> 1;
    }
}


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -


<span class="enscript-comment">/*
 * ATAPI stuff
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">long</span>
<span class="enscript-function-name">get_pi_info</span>(<span class="enscript-type">long</span> id, <span class="enscript-type">struct</span> ATAPI_identify_drive_info *ip)
{
    ataIdentify     pb;
    OSErr           status;
    <span class="enscript-type">long</span>            rtn_value;

    <span class="enscript-keyword">if</span> (<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ATAPI_identify_drive_info) &lt; 512) {
	<span class="enscript-keyword">return</span> 0;
    }
    clear_memory((<span class="enscript-type">void</span> *)ip, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ATAPI_identify_drive_info));

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    pb.ataPBFunctionCode    =   kATAMgrDriveIdentify;
    pb.ataPBVers            =   kATAPBVers1;
    pb.ataPBDeviceID        =   id;
    pb.ataPBFlags           =   mATAFlagIORead | mATAFlagByteSwap | mATAFlagProtocol1;
    pb.ataPBTimeOut         =   kATAtimeout;
    pb.ataPBBuffer          =   (<span class="enscript-type">void</span>*) ip;
    
    status = ataManager((ataPB*) &amp;pb );

    <span class="enscript-keyword">if</span> (status != noErr) {
	<span class="enscript-comment">//printf(&quot;get pi info status = %d\n&quot;, status);
</span>	rtn_value = 0;
    } <span class="enscript-keyword">else</span> {
	rtn_value = 1;
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


MEDIA
<span class="enscript-function-name">open_atapi_as_media</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> device)
{
    ATA_MEDIA   a;
    <span class="enscript-type">long</span>        id;
    <span class="enscript-type">struct</span> ATAPI_identify_drive_info    info;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buf;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> block_size;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> blocks;   
    
    <span class="enscript-keyword">if</span> (ata_inited == 0) {
	ata_init();
    }
    
    <span class="enscript-keyword">if</span> (ata_mgr.exists == 0) {
	<span class="enscript-keyword">return</span> 0;
    }

    id = compute_id(bus, device);

    <span class="enscript-keyword">if</span> (!is_atapi(id)) {
	a = 0;

    } <span class="enscript-keyword">else</span> {
	a = 0;
	<span class="enscript-keyword">if</span> (get_pi_info(id, &amp;info) != 0
		&amp;&amp; (info.capabilities &amp; LBA_CAPABLE) != 0) {
	    <span class="enscript-keyword">if</span> (ATAPI_TestUnitReady(id) != 0) {
		a = new_ata_media();
		<span class="enscript-keyword">if</span> (a != 0) {
		    a-&gt;m.kind = ata_mgr.kind;
		    <span class="enscript-keyword">if</span> (ATAPI_ReadCapacity(id, &amp;block_size, &amp;blocks) == 0) {
			block_size = 2048;
			blocks = 1000;
		    }
		    a-&gt;m.grain = block_size;
		    a-&gt;m.size_in_bytes = ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)blocks) * a-&gt;m.grain;
		    a-&gt;m.do_read = read_atapi_media;
		    a-&gt;m.do_write = write_atapi_media;
		    a-&gt;m.do_close = close_ata_media;
		    a-&gt;m.do_os_reload = os_reload_ata_media;
		    a-&gt;id = id;
		}
	    } <span class="enscript-keyword">else</span> {
		printf(<span class="enscript-string">&quot;ATAPI - unit not ready\n&quot;</span>);
	    }
	} <span class="enscript-keyword">else</span> {
	    printf(<span class="enscript-string">&quot;ATAPI - couldn't get info or not LBA capable\n&quot;</span>);
	}
    }
    <span class="enscript-keyword">return</span> (MEDIA) a;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">read_atapi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address)
{
    ATA_MEDIA a;
    ataIOPB pb;
    OSErr       status;
    <span class="enscript-type">long</span> rtn_value;
    <span class="enscript-type">long</span> block;
    <span class="enscript-type">long</span> block_count;
    <span class="enscript-type">long</span> block_size;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer;
    <span class="enscript-type">int</span> i;
    
    a = (ATA_MEDIA) m;
    rtn_value = 0;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != ata_mgr.kind) {
	<span class="enscript-comment">/* wrong kind - XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (count &lt;= 0 || count % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle size */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset &lt; 0 || offset % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle offset */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset + count &gt; a-&gt;m.size_in_bytes) {
	<span class="enscript-comment">/* check for offset (and offset+count) too large */</span>
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* XXX do a read on the physical device */</span>
	block_size = a-&gt;m.grain;
	block = offset / block_size;
	block_count = count / block_size;
	buffer = address;
	rtn_value = 1;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; block_count; i++) {
	    <span class="enscript-keyword">if</span> (ATAPI_ReadBlock(a-&gt;id, block_size, block, buffer) == 0) {
		rtn_value = 0;
		<span class="enscript-keyword">break</span>;
	    }
	    buffer += block_size;
	    block += 1;
	}
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">write_atapi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address)
{   
    <span class="enscript-keyword">return</span> 0;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ATAPI_ReadBlock</span>(UInt32 deviceID, UInt32 block_size, UInt32 block, UInt8 *address)
{
    ataIOPB         pb;
    OSErr           status;
    <span class="enscript-type">long</span>            slave;
    ATAPICmdPacket  cmdPacket;
    SCSI_10_Byte_Command *gRead;
    <span class="enscript-type">long</span> count;

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    pb.ataPBFunctionCode    =   kATAMgrExecIO;
    pb.ataPBVers            =   kATAPBVers1;
    pb.ataPBDeviceID        =   deviceID;
    pb.ataPBFlags           =   mATAFlagTFRead | mATAFlagIORead | mATAFlagProtocol1;
    pb.ataPBTimeOut         =   kATAtimeout;
    
    pb.ataPBBuffer          =   address;
    pb.ataPBByteCount = block_size;
    pb.ataPBTaskFile.ataTFCylinder = block_size;
    <span class="enscript-keyword">if</span> (deviceID &amp; 0x0FF00) {
	slave = 0x10;
    } <span class="enscript-keyword">else</span> {
	slave = 0x0;
    }
			      <span class="enscript-comment">/* std | L/C  | Drive | head */</span>
    pb.ataPBTaskFile.ataTFSDH = 0xA0 | 0x40 | slave;
    pb.ataPBTaskFile.ataTFCommand = kATAcmdATAPIPacket;
    pb.ataPBPacketPtr = &amp;cmdPacket;
    
    cmdPacket.atapiPacketSize = 16;
    clear_memory((<span class="enscript-type">void</span> *)&amp;cmdPacket.atapiCommandByte, 16);
    gRead = (SCSI_10_Byte_Command *) &amp;cmdPacket.atapiCommandByte[0];

    gRead-&gt;opcode = kScsiCmdRead10;

    gRead-&gt;lbn4 = (block &gt;&gt; 24) &amp; 0xFF;
    gRead-&gt;lbn3 = (block &gt;&gt; 16) &amp; 0xFF;
    gRead-&gt;lbn2 = (block &gt;&gt; 8) &amp; 0xFF;
    gRead-&gt;lbn1 = block &amp; 0xFF;

    count = 1;
    gRead-&gt;len2 = (count &gt;&gt; 8) &amp; 0xFF;
    gRead-&gt;len1 = count &amp; 0xFF;


    status = ataManager((ataPB*) &amp;pb );
    <span class="enscript-keyword">if</span> (status != noErr) {
	<span class="enscript-comment">/* failure */</span>
	<span class="enscript-comment">//printf(&quot;ATAPI read status = %d\n&quot;, status);
</span>	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">return</span> 1;
    }
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ATAPI_TestUnitReady</span>(UInt32 deviceID)
{
    ataIOPB         pb;
    OSErr           status;
    <span class="enscript-type">long</span>            slave;
    ATAPICmdPacket  cmdPacket;
    SCSI_10_Byte_Command *gTestUnit;

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    pb.ataPBFunctionCode    =   kATAMgrExecIO;
    pb.ataPBVers            =   kATAPBVers1;
    pb.ataPBDeviceID        =   deviceID;
    pb.ataPBFlags           =   mATAFlagTFRead | mATAFlagIORead | mATAFlagProtocol1;
    pb.ataPBTimeOut         =   kATAtimeout;
    
    <span class="enscript-keyword">if</span> (deviceID &amp; 0x0FF00) {
	slave = 0x10;
    } <span class="enscript-keyword">else</span> {
	slave = 0x0;
    }
			      <span class="enscript-comment">/* std | L/C  | Drive | head */</span>
    pb.ataPBTaskFile.ataTFSDH = 0xA0 | 0x40 | slave;
    pb.ataPBTaskFile.ataTFCommand = kATAcmdATAPIPacket;
    pb.ataPBPacketPtr = &amp;cmdPacket;
    
    cmdPacket.atapiPacketSize = 16;
    clear_memory((<span class="enscript-type">void</span> *)&amp;cmdPacket.atapiCommandByte, 16);
    gTestUnit = (SCSI_10_Byte_Command *) &amp;cmdPacket.atapiCommandByte[0];

    gTestUnit-&gt;opcode = kScsiCmdTestUnitReady;


    status = ataManager((ataPB*) &amp;pb );
    <span class="enscript-keyword">if</span> (status != noErr) {
	<span class="enscript-comment">/* failure */</span>
	<span class="enscript-comment">//printf(&quot;ATAPI test unit ready status = %d\n&quot;, status);
</span>	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">return</span> 1;
    }
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">ATAPI_ReadCapacity</span>(UInt32 deviceID, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *block_size, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> *blocks)
{
    ataIOPB         pb;
    OSErr           status;
    <span class="enscript-type">long</span>            slave;
    ATAPICmdPacket  cmdPacket;
    SCSI_10_Byte_Command *gReadCap;
    <span class="enscript-type">struct</span> read_cap_data {
	<span class="enscript-type">long</span>    addr;
	<span class="enscript-type">long</span>    size;
    } rcd;

    clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
    pb.ataPBFunctionCode    =   kATAMgrExecIO;
    pb.ataPBVers            =   kATAPBVers1;
    pb.ataPBDeviceID        =   deviceID;
    pb.ataPBFlags           =   mATAFlagTFRead | mATAFlagIORead | mATAFlagProtocol1;
    pb.ataPBTimeOut         =   kATAtimeout;
    
    pb.ataPBBuffer          =   (<span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *)&amp;rcd;
    pb.ataPBByteCount = 8;
    pb.ataPBTaskFile.ataTFCylinder = 8;
    <span class="enscript-keyword">if</span> (deviceID &amp; 0x0FF00) {
	slave = 0x10;
    } <span class="enscript-keyword">else</span> {
	slave = 0x0;
    }
			      <span class="enscript-comment">/* std | L/C  | Drive | head */</span>
    pb.ataPBTaskFile.ataTFSDH = 0xA0 | 0x40 | slave;
    pb.ataPBTaskFile.ataTFCommand = kATAcmdATAPIPacket;
    pb.ataPBPacketPtr = &amp;cmdPacket;
    
    cmdPacket.atapiPacketSize = 16;
    clear_memory((<span class="enscript-type">void</span> *)&amp;cmdPacket.atapiCommandByte, 16);
    gReadCap = (SCSI_10_Byte_Command *) &amp;cmdPacket.atapiCommandByte[0];

    gReadCap-&gt;opcode = kScsiCmdReadCapacity;


    status = ataManager((ataPB*) &amp;pb );
    <span class="enscript-keyword">if</span> (status != noErr) {
	<span class="enscript-comment">/* failure */</span>
	<span class="enscript-comment">//printf(&quot;ATAPI read capacity status = %d\n&quot;, status);
</span>	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> {
	*blocks = rcd.addr;
	*block_size = rcd.size;
	<span class="enscript-keyword">return</span> 1;
    }
}


MEDIA
<span class="enscript-function-name">ATA_FindDevice</span>(<span class="enscript-type">long</span> dRefNum)
{
    ataDrvrRegister pb;
    OSErr       status;

    <span class="enscript-keyword">if</span> (ATAManagerPresent()) {
	clear_memory((<span class="enscript-type">void</span> *)&amp;pb, <span class="enscript-keyword">sizeof</span>(pb));
	
	pb.ataPBFunctionCode    =   kATAMgrFindDriverRefnum;
	pb.ataPBVers            =   kATAPBVers1;
	pb.ataPBDeviceID        =   0xFFFF;
	pb.ataPBTimeOut         =   kATAtimeout;
	
	pb.ataDeviceNextID = 1;     
	<span class="enscript-keyword">do</span> {
	    status = ataManager((ataPB*) &amp;pb);
	    
	    <span class="enscript-keyword">if</span> (status != noErr) {
		<span class="enscript-keyword">break</span>;
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pb.ataDrvrRefNum == dRefNum
		    &amp;&amp; pb.ataPBDeviceID != kNoDevice) {
		<span class="enscript-keyword">return</span> open_ata_as_media(pb.ataPBDeviceID &amp; 0xFF,
			(pb.ataPBDeviceID &gt;&gt; 8) &amp; 0xFF);
	    } <span class="enscript-keyword">else</span> {
		pb.ataPBDeviceID = pb.ataDeviceNextID;
	    }
	} <span class="enscript-keyword">while</span> (pb.ataPBDeviceID != kNoDevice);
    }
    <span class="enscript-keyword">return</span> 0;
}


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -


ATA_MEDIA_ITERATOR
<span class="enscript-function-name">new_ata_iterator</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (ATA_MEDIA_ITERATOR) new_media_iterator(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ATA_media_iterator));
}


MEDIA_ITERATOR
<span class="enscript-function-name">create_ata_iterator</span>(<span class="enscript-type">void</span>)
{
    ATA_MEDIA_ITERATOR a;
    
    <span class="enscript-keyword">if</span> (ata_inited == 0) {
	ata_init();
    }
    
    <span class="enscript-keyword">if</span> (ata_mgr.exists == 0) {
	<span class="enscript-keyword">return</span> 0;
    }

    a = new_ata_iterator();
    <span class="enscript-keyword">if</span> (a != 0) {
	a-&gt;m.kind = ata_mgr.kind;
	a-&gt;m.state = kInit;
	a-&gt;m.do_reset = reset_ata_iterator;
	a-&gt;m.do_step = step_ata_iterator;
	a-&gt;m.do_delete = delete_ata_iterator;
	a-&gt;bus_index = 0;
	a-&gt;bus = 0;
	a-&gt;id = 0;
    }

    <span class="enscript-keyword">return</span> (MEDIA_ITERATOR) a;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">reset_ata_iterator</span>(MEDIA_ITERATOR m)
{
    ATA_MEDIA_ITERATOR a;
    
    a = (ATA_MEDIA_ITERATOR) m;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != ata_mgr.kind) {
	<span class="enscript-comment">/* wrong kind - XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.state != kInit) {
	a-&gt;m.state = kReset;
    }
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">step_ata_iterator</span>(MEDIA_ITERATOR m)
{
    ATA_MEDIA_ITERATOR a;
    <span class="enscript-type">char</span> *result;
    
    a = (ATA_MEDIA_ITERATOR) m;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != ata_mgr.kind) {
	<span class="enscript-comment">/* wrong kind - XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">switch</span> (a-&gt;m.state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kInit</span>:
	    <span class="enscript-comment">/* find # of buses (done in ata_init) */</span>
	    a-&gt;m.state = kReset;
	    <span class="enscript-comment">/* fall through to reset */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kReset</span>:
	    a-&gt;bus_index = 0 <span class="enscript-comment">/* low bus id */</span>;
	    a-&gt;bus = ata_mgr.bus_list[a-&gt;bus_index];
	    a-&gt;id = 0 <span class="enscript-comment">/* low device id */</span>;
	    a-&gt;m.state = kIterating;
	    <span class="enscript-comment">/* fall through to iterate */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIterating</span>:
	    <span class="enscript-keyword">while</span> (1) {
		<span class="enscript-keyword">if</span> (a-&gt;bus_index &gt;= ata_mgr.busCount<span class="enscript-comment">/* max bus id */</span>) {
		    <span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (a-&gt;id &gt; 1 <span class="enscript-comment">/*max id for bus */</span>) {
		    a-&gt;bus_index += 1;
		    a-&gt;bus = ata_mgr.bus_list[a-&gt;bus_index];
		    a-&gt;id = 0 <span class="enscript-comment">/* low device id */</span>;
		    <span class="enscript-keyword">continue</span>;   <span class="enscript-comment">/* try again */</span>
		}
		<span class="enscript-keyword">if</span> (a-&gt;bus &gt; 9) {
		    <span class="enscript-comment">// insure that name creation works
</span>		    <span class="enscript-keyword">break</span>;
		}
		<span class="enscript-comment">/* generate result */</span>
		result = (<span class="enscript-type">char</span> *) malloc(20);
		<span class="enscript-keyword">if</span> (result != NULL) {
		    snprintf(result, 20, <span class="enscript-string">&quot;/dev/ata%c.%c&quot;</span>,
		        <span class="enscript-string">'0'</span>+a-&gt;bus, <span class="enscript-string">'0'</span>+a-&gt;id);
		}

		a-&gt;id += 1; <span class="enscript-comment">/* next id */</span>
		<span class="enscript-keyword">return</span> result;
	    }
	    a-&gt;m.state = kEnd;
	    <span class="enscript-comment">/* fall through to end */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kEnd</span>:
	<span class="enscript-reference">default</span>:
	    <span class="enscript-keyword">break</span>;
	}
    }
    <span class="enscript-keyword">return</span> 0 <span class="enscript-comment">/* no entry */</span>;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">delete_ata_iterator</span>(MEDIA_ITERATOR m)
{
    <span class="enscript-keyword">return</span>;
}


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -


#<span class="enscript-reference">ifdef</span> <span class="enscript-variable-name">notdef</span>
MEDIA
<span class="enscript-function-name">open_linux_ata_as_media</span>(<span class="enscript-type">long</span> index)
{
    <span class="enscript-type">long</span> bus;
    <span class="enscript-type">long</span> id;
    <span class="enscript-type">long</span> i;
    
    i = index / 2;
    <span class="enscript-keyword">if</span> (i &gt;= ata_mgr.busCount) {
	<span class="enscript-comment">// set bogus id
</span>	bus = 0;
	id = 2;
    } <span class="enscript-keyword">else</span> {
	bus = ata_mgr.bus_list[index / 2];
	id = index % 2;
    }

    <span class="enscript-keyword">return</span> open_ata_as_media(bus, id);
}

#<span class="enscript-reference">else</span>

MEDIA
<span class="enscript-function-name">open_linux_ata_as_media</span>(<span class="enscript-type">long</span> index)
{
    <span class="enscript-type">long</span> bus;
    <span class="enscript-type">long</span> id;
    
    bus = index / 2;
    id = index % 2;

    <span class="enscript-keyword">return</span> open_ata_as_media(bus, id);
}
#<span class="enscript-reference">endif</span>


<span class="enscript-type">char</span> *
<span class="enscript-function-name">linux_ata_name</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id)
{
    <span class="enscript-type">char</span> *result;

    <span class="enscript-keyword">if</span> (bus &gt;= 13) {
	<span class="enscript-comment">// a bus &gt;= 13 would be a bogus character
</span>	<span class="enscript-keyword">return</span> NULL;
    }
    result = (<span class="enscript-type">char</span> *) malloc(20);
    <span class="enscript-keyword">if</span> (result != NULL) {
    	<span class="enscript-comment">/* name is hda, hdb, hdc, hdd, ...
    	 * in order (0,0)  (0,1)  (1,0)  (1,1) ...
    	 */</span>
	snprintf(result, 20, <span class="enscript-string">&quot;/dev/hd%c&quot;</span>, <span class="enscript-string">'a'</span> + (bus*2 + id));
    }
    <span class="enscript-keyword">return</span> result;
}
</pre>
<hr />
</body></html>