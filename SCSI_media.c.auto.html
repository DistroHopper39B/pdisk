<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>SCSI_media.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
</head>
<body id="top">
<h1 style="margin:8px;" id="f1">SCSI_media.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="SCSI_media.c">plain text</a>]</span></h1>
<hr/>
<div></div>
<pre>
<span class="enscript-comment">/*
 * SCSI_media.c -
 *
 * Written by Eryk Vershen
 */</span>

<span class="enscript-comment">/*
 * Copyright 1997,1998 by Apple Computer, Inc.
 *              All Rights Reserved 
 *  
 * Permission to use, copy, modify, and distribute this software and 
 * its documentation for any purpose and without fee is hereby granted, 
 * provided that the above copyright notice appears in all copies and 
 * that both the copyright notice and this permission notice appear in 
 * supporting documentation. 
 *  
 * APPLE COMPUTER DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE 
 * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS 
 * FOR A PARTICULAR PURPOSE. 
 *  
 * IN NO EVENT SHALL APPLE COMPUTER BE LIABLE FOR ANY SPECIAL, INDIRECT, OR 
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM 
 * LOSS OF USE, DATA OR PROFITS, WHETHER IN ACTION OF CONTRACT, 
 * NEGLIGENCE, OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION 
 * WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. 
 */</span>


<span class="enscript-comment">// for printf() &amp; sprintf()
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
<span class="enscript-comment">// for malloc() &amp; free()
</span>#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdlib.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;DoSCSICommand.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;SCSI_media.h&quot;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&quot;util.h&quot;</span>


<span class="enscript-comment">/*
 * Defines
 */</span>
#<span class="enscript-reference">define</span> <span class="enscript-function-name">DriverRefNumToSCSI</span>(x)  ((signed short) (~(x) - 32))


<span class="enscript-comment">/*
 * Types
 */</span>
<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> SCSI_media *SCSI_MEDIA;

<span class="enscript-type">struct</span> SCSI_media {
    <span class="enscript-type">struct</span> media    m;
    <span class="enscript-type">long</span>            bus;
    <span class="enscript-type">long</span>            id;
};

<span class="enscript-type">struct</span> bus_entry {
    <span class="enscript-type">long</span>    bus;
    <span class="enscript-type">long</span>    sort_value;
    <span class="enscript-type">long</span>    max_id;
    <span class="enscript-type">long</span>    master_id;
};

<span class="enscript-type">struct</span> SCSI_manager {
    <span class="enscript-type">long</span>        exists;
    <span class="enscript-type">long</span>        kind;
    <span class="enscript-type">long</span>        bus_count;
    <span class="enscript-type">struct</span> bus_entry *bus_list;
};

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> SCSI_media_iterator *SCSI_MEDIA_ITERATOR;

<span class="enscript-type">struct</span> SCSI_media_iterator {
    <span class="enscript-type">struct</span> media_iterator   m;
    <span class="enscript-type">long</span>                    bus_index;
    <span class="enscript-type">long</span>                    bus;
    <span class="enscript-type">long</span>                    id;
};

<span class="enscript-type">struct</span> linux_order_cache {
    <span class="enscript-type">struct</span> cache_item *first;
    <span class="enscript-type">struct</span> cache_item *last;
    <span class="enscript-type">long</span> next_disk;
    <span class="enscript-type">long</span> next_cdrom;
    <span class="enscript-type">long</span> loaded;
};

<span class="enscript-type">struct</span> cache_item {
    <span class="enscript-type">struct</span> cache_item *next;
    <span class="enscript-type">long</span> bus;
    <span class="enscript-type">long</span> id;
    <span class="enscript-type">long</span> value;
    <span class="enscript-type">long</span> is_cdrom;
    <span class="enscript-type">long</span> unsure;
};


<span class="enscript-comment">/*
 * Global Constants
 */</span>
<span class="enscript-type">enum</span> {
    kNoDevice = 0x00FF
};

<span class="enscript-type">enum</span> {
    kRequiredSCSIinquiryLength = 36
};


<span class="enscript-comment">/*
 * Global Variables
 */</span>
<span class="enscript-type">static</span> <span class="enscript-type">long</span> scsi_inited = 0;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> SCSI_manager scsi_mgr;
<span class="enscript-type">static</span> <span class="enscript-type">struct</span> linux_order_cache linux_order;


<span class="enscript-comment">/*
 * Forward declarations
 */</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">AsyncSCSIPresent</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">scsi_init</span>(<span class="enscript-type">void</span>);
SCSI_MEDIA <span class="enscript-function-name">new_scsi_media</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">long</span> <span class="enscript-function-name">read_scsi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address);
<span class="enscript-type">long</span> <span class="enscript-function-name">write_scsi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address);
<span class="enscript-type">long</span> <span class="enscript-function-name">close_scsi_media</span>(MEDIA m);
<span class="enscript-type">long</span> <span class="enscript-function-name">os_reload_scsi_media</span>(MEDIA m);
<span class="enscript-type">long</span> <span class="enscript-function-name">compute_id</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> device);
<span class="enscript-type">int</span> <span class="enscript-function-name">SCSI_ReadBlock</span>(UInt32 id, UInt32 bus, UInt32 block_size, UInt32 block, UInt8 *address);
<span class="enscript-type">int</span> <span class="enscript-function-name">SCSI_WriteBlock</span>(UInt32 id, UInt32 bus, UInt32 block_size, UInt32 block, UInt8 *address);
<span class="enscript-type">int</span> <span class="enscript-function-name">DoTestUnitReady</span>(UInt8 targetID, <span class="enscript-type">int</span> bus);
<span class="enscript-type">int</span> <span class="enscript-function-name">DoReadCapacity</span>(UInt32 id, UInt32 bus, UInt32 *blockCount, UInt32 *blockSize);
SCSI_MEDIA_ITERATOR <span class="enscript-function-name">new_scsi_iterator</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">reset_scsi_iterator</span>(MEDIA_ITERATOR m);
<span class="enscript-type">char</span> *<span class="enscript-function-name">step_scsi_iterator</span>(MEDIA_ITERATOR m);
<span class="enscript-type">void</span> <span class="enscript-function-name">delete_scsi_iterator</span>(MEDIA_ITERATOR m);
<span class="enscript-type">void</span> <span class="enscript-function-name">fill_bus_entry</span>(<span class="enscript-type">struct</span> bus_entry *entry, <span class="enscript-type">long</span> bus);
<span class="enscript-comment">/*long get_bus_sort_value(long bus);*/</span>
<span class="enscript-type">int</span> <span class="enscript-function-name">bus_entry_compare</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span>* a, <span class="enscript-type">const</span> <span class="enscript-type">void</span>* b);
<span class="enscript-type">int</span> <span class="enscript-function-name">DoInquiry</span>(UInt32 id, UInt32 bus, UInt32 *devType);
<span class="enscript-type">void</span> <span class="enscript-function-name">probe_all</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">probe_scsi_device</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id, <span class="enscript-type">int</span> unsure);
<span class="enscript-type">long</span> <span class="enscript-function-name">lookup_scsi_device</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id, <span class="enscript-type">int</span> *is_cdrom, <span class="enscript-type">int</span> *unsure);
<span class="enscript-type">long</span> <span class="enscript-function-name">lookup_scsi_index</span>(<span class="enscript-type">long</span> index, <span class="enscript-type">int</span> is_cdrom, <span class="enscript-type">long</span> *bus, <span class="enscript-type">long</span> *id);
<span class="enscript-type">void</span> <span class="enscript-function-name">add_to_cache</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id, <span class="enscript-type">int</span> is_cdrom, <span class="enscript-type">int</span> unsure);
<span class="enscript-type">void</span> <span class="enscript-function-name">init_linux_cache</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">clear_linux_cache</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">void</span> <span class="enscript-function-name">mark_linux_cache_loaded</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">int</span> <span class="enscript-function-name">linux_cache_loaded</span>(<span class="enscript-type">void</span>);


<span class="enscript-comment">/*
 * Routines
 */</span>
<span class="enscript-type">int</span>
<span class="enscript-function-name">AsyncSCSIPresent</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (TrapAvailable(_SCSIAtomic));
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">scsi_init</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">int</span> i;
    <span class="enscript-type">int</span> old_scsi;
    
    <span class="enscript-keyword">if</span> (scsi_inited != 0) {
	<span class="enscript-keyword">return</span>;
    }
    scsi_inited = 1;
    
    scsi_mgr.exists = 1;
    scsi_mgr.kind = allocate_media_kind();

    <span class="enscript-keyword">if</span> (AsyncSCSIPresent()) {
	AllocatePB();

	scsi_mgr.bus_count = gSCSIHiBusID + 1;
	old_scsi = 0;
    } <span class="enscript-keyword">else</span> {
	scsi_mgr.bus_count = 1;
	old_scsi = 1;
    }
    
    scsi_mgr.bus_list = (<span class="enscript-type">struct</span> bus_entry *)
	    calloc(scsi_mgr.bus_count, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bus_entry));
	    
    <span class="enscript-keyword">if</span> (scsi_mgr.bus_list == 0) {
	scsi_mgr.bus_count = 0;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">for</span> (i = 0; i &lt; scsi_mgr.bus_count; i++) {
	    <span class="enscript-keyword">if</span> (old_scsi) {
		scsi_mgr.bus_list[i].bus = 0xFF;
	    } <span class="enscript-keyword">else</span> {
		scsi_mgr.bus_list[i].bus = i;
	    }
	    fill_bus_entry(&amp;scsi_mgr.bus_list[i], i);
	}
	qsort((<span class="enscript-type">void</span> *)scsi_mgr.bus_list,    <span class="enscript-comment">/* address of array */</span>
		scsi_mgr.bus_count,         <span class="enscript-comment">/* number of elements */</span>
		<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> bus_entry),   <span class="enscript-comment">/* size of element */</span>
		bus_entry_compare);         <span class="enscript-comment">/* element comparison routine */</span>
    }
    
    init_linux_cache();
}

<span class="enscript-type">void</span>
<span class="enscript-function-name">fill_bus_entry</span>(<span class="enscript-type">struct</span> bus_entry *entry, <span class="enscript-type">long</span> bus)
{
    OSErr           status;
    SCSIBusInquiryPB    pb;
    <span class="enscript-type">long</span> len;
    <span class="enscript-type">long</span> result;
    <span class="enscript-type">long</span> x, y;

    <span class="enscript-keyword">if</span> (!AsyncSCSIPresent()) {
    	entry-&gt;sort_value = 0;
	entry-&gt;max_id = 7;
	entry-&gt;master_id = 7;
	<span class="enscript-keyword">return</span>;
    }
    len = <span class="enscript-keyword">sizeof</span>(SCSIBusInquiryPB);
    clear_memory((Ptr) &amp;pb, len);
    pb.scsiPBLength = len;
    pb.scsiFunctionCode = SCSIBusInquiry;
    pb.scsiDevice.bus = bus;
    status = SCSIAction((SCSI_PB *) &amp;pb);
    <span class="enscript-keyword">if</span> (status != noErr) {
	result = 6;
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">switch</span> (pb.scsiHBAslotType) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiMotherboardBus</span>:    x = 0; <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiPDSBus</span>:            x = 1; <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiNuBus</span>:             x = 2; <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiPCIBus</span>:            x = 3; <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiFireWireBridgeBus</span>: x = 4; <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiPCMCIABus</span>:         x = 5; <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:                    x = 7 + pb.scsiHBAslotType; <span class="enscript-keyword">break</span>;
	};
	
	<span class="enscript-keyword">switch</span> (pb.scsiFeatureFlags &amp; scsiBusInternalExternalMask) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiBusInternal</span>:                   y = 0; <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiBusInternalExternal</span>:           y = 1; <span class="enscript-keyword">break</span>;
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiBusExternal</span>:                   y = 2; <span class="enscript-keyword">break</span>;
	<span class="enscript-reference">default</span>:
	<span class="enscript-keyword">case</span> <span class="enscript-reference">scsiBusInternalExternalUnknown</span>:    y = 3; <span class="enscript-keyword">break</span>;
	};
	result = x * 4 + y;
    }
    entry-&gt;sort_value = result;
    entry-&gt;max_id = pb.scsiMaxLUN;
    entry-&gt;master_id = pb.scsiInitiatorID;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">bus_entry_compare</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span>* a, <span class="enscript-type">const</span> <span class="enscript-type">void</span>* b)
{
    <span class="enscript-type">long</span> result;
    
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bus_entry *x = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> bus_entry *) a;
    <span class="enscript-type">const</span> <span class="enscript-type">struct</span> bus_entry *y = (<span class="enscript-type">const</span> <span class="enscript-type">struct</span> bus_entry *) b;
    
    result = x-&gt;sort_value - y-&gt;sort_value;
    <span class="enscript-keyword">if</span> (result == 0) {
	result = x-&gt;bus - y-&gt;bus;
    }
    <span class="enscript-keyword">return</span> result;
}


SCSI_MEDIA
<span class="enscript-function-name">new_scsi_media</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (SCSI_MEDIA) new_media(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> SCSI_media));
}


MEDIA
<span class="enscript-function-name">open_old_scsi_as_media</span>(<span class="enscript-type">long</span> device)
{
    <span class="enscript-keyword">return</span> open_scsi_as_media(kOriginalSCSIBusAdaptor, device);
}


MEDIA
<span class="enscript-function-name">open_scsi_as_media</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> device)
{
    SCSI_MEDIA  a;
    UInt32 blockCount;
    UInt32 blockSize;
    
    <span class="enscript-keyword">if</span> (scsi_inited == 0) {
	scsi_init();
    }
    
    <span class="enscript-keyword">if</span> (scsi_mgr.exists == 0) {
	<span class="enscript-keyword">return</span> 0;
    }

    a = 0;
    <span class="enscript-keyword">if</span> (DoTestUnitReady(device, bus) &gt; 0) {
	<span class="enscript-keyword">if</span> (DoReadCapacity(device, bus, &amp;blockCount, &amp;blockSize) != 0) {
	    a = new_scsi_media();
	    <span class="enscript-keyword">if</span> (a != 0) {
		a-&gt;m.kind = scsi_mgr.kind;
		a-&gt;m.grain = blockSize;
		a-&gt;m.size_in_bytes = ((<span class="enscript-type">long</span> <span class="enscript-type">long</span>)blockCount) * blockSize;
		a-&gt;m.do_read = read_scsi_media;
		a-&gt;m.do_write = write_scsi_media;
		a-&gt;m.do_close = close_scsi_media;
		a-&gt;m.do_os_reload = os_reload_scsi_media;
		a-&gt;bus = bus;
		a-&gt;id = device;
	    }
	}
    }
    <span class="enscript-keyword">return</span> (MEDIA) a;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">read_scsi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address)
{
    SCSI_MEDIA a;
    <span class="enscript-type">long</span> rtn_value;
    <span class="enscript-type">long</span> block;
    <span class="enscript-type">long</span> block_count;
    <span class="enscript-type">long</span> block_size;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer;
    <span class="enscript-type">int</span> i;
    
    block = (<span class="enscript-type">long</span>) offset;
<span class="enscript-comment">//printf(&quot;scsi %d count %d\n&quot;, block, count);
</span>    a = (SCSI_MEDIA) m;
    rtn_value = 0;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != scsi_mgr.kind) {
	<span class="enscript-comment">/* wrong kind - XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (count &lt;= 0 || count % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle size */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset &lt; 0 || offset % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle offset */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset + count &gt; a-&gt;m.size_in_bytes) {
	<span class="enscript-comment">/* check for offset (and offset+count) too large */</span>
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* XXX do a read on the physical device */</span>
	block_size = a-&gt;m.grain;
	block = offset / block_size;
	block_count = count / block_size;
	buffer = address;
	rtn_value = 1;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; block_count; i++) {
	    <span class="enscript-keyword">if</span> (SCSI_ReadBlock(a-&gt;id, a-&gt;bus, block_size, block, buffer) == 0) {
		rtn_value = 0;
		<span class="enscript-keyword">break</span>;
	    }
	    buffer += block_size;
	    block += 1;
	}
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">write_scsi_media</span>(MEDIA m, <span class="enscript-type">long</span> <span class="enscript-type">long</span> offset, <span class="enscript-type">unsigned</span> <span class="enscript-type">long</span> count, <span class="enscript-type">void</span> *address)
{
    SCSI_MEDIA a;
    <span class="enscript-type">long</span> rtn_value;
    <span class="enscript-type">long</span> block;
    <span class="enscript-type">long</span> block_count;
    <span class="enscript-type">long</span> block_size;
    <span class="enscript-type">unsigned</span> <span class="enscript-type">char</span> *buffer;
    <span class="enscript-type">int</span> i;
    
    a = (SCSI_MEDIA) m;
    rtn_value = 0;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != scsi_mgr.kind) {
	<span class="enscript-comment">/* XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (count &lt;= 0 || count % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle size */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset &lt; 0 || offset % a-&gt;m.grain != 0) {
	<span class="enscript-comment">/* can't handle offset */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (offset + count &gt; a-&gt;m.size_in_bytes) {
	<span class="enscript-comment">/* check for offset (and offset+count) too large */</span>
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-comment">/* XXX do a write on the physical device */</span>
	block_size = a-&gt;m.grain;
	block = offset / block_size;
	block_count = count / block_size;
	buffer = address;
	rtn_value = 1;
	<span class="enscript-keyword">for</span> (i = 0; i &lt; block_count; i++) {
	    <span class="enscript-keyword">if</span> (SCSI_WriteBlock(a-&gt;id, a-&gt;bus, block_size, block, buffer) == 0) {
		rtn_value = 0;
		<span class="enscript-keyword">break</span>;
	    }
	    buffer += block_size;
	    block += 1;
	}
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">close_scsi_media</span>(MEDIA m)
{
    SCSI_MEDIA a;
    
    a = (SCSI_MEDIA) m;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-keyword">return</span> 0;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != scsi_mgr.kind) {
	<span class="enscript-comment">/* XXX need to error here - this is an internal problem */</span>
	<span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-comment">/* XXX nothing to do - I think? */</span>
    <span class="enscript-keyword">return</span> 1;
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">os_reload_scsi_media</span>(MEDIA m)
{
    printf(<span class="enscript-string">&quot;Reboot your system so the partition table will be reread.\n&quot;</span>);
    <span class="enscript-keyword">return</span> 1;
}


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -


<span class="enscript-type">int</span>
<span class="enscript-function-name">DoTestUnitReady</span>(UInt8 targetID, <span class="enscript-type">int</span> bus)
{
    OSErr                   status;
    Str255                  errorText;
    <span class="enscript-type">char</span>*       msg;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> SCSI_6_Byte_Command gTestUnitReadyCommand = {
	kScsiCmdTestUnitReady, 0, 0, 0, 0, 0
    };
    SCSI_Sense_Data         senseData;
    DeviceIdent scsiDevice;
    <span class="enscript-type">int</span> rtn_value;

    scsiDevice.diReserved = 0;
    scsiDevice.bus = bus;
    scsiDevice.targetID = targetID;
    scsiDevice.LUN = 0;

    status = DoSCSICommand(
		scsiDevice,
		<span class="enscript-string">&quot;\pTest Unit Ready&quot;</span>,
		(SCSI_CommandPtr) &amp;gTestUnitReadyCommand,
		NULL,
		0,
		scsiDirectionNone,
		NULL,
		&amp;senseData,
		errorText
		);
    <span class="enscript-keyword">if</span> (status == scsiNonZeroStatus) {
	rtn_value = -1;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (status != noErr) {
	rtn_value = 0;
    } <span class="enscript-keyword">else</span> {
	rtn_value = 1;
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">SCSI_ReadBlock</span>(UInt32 id, UInt32 bus, UInt32 block_size, UInt32 block, UInt8 *address)
{
    OSErr                   status;
    Str255                  errorText;
    <span class="enscript-type">char</span>*       msg;
    <span class="enscript-type">static</span> SCSI_10_Byte_Command gReadCommand = {
	kScsiCmdRead10, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    SCSI_Sense_Data         senseData;
    DeviceIdent scsiDevice;
    <span class="enscript-type">int</span> rtn_value;
    <span class="enscript-type">long</span> count;

<span class="enscript-comment">//printf(&quot;scsi read %d:%d block %d size %d\n&quot;, bus, id, block, block_size);
</span>    scsiDevice.diReserved = 0;
    scsiDevice.bus = bus;
    scsiDevice.targetID = id;
    scsiDevice.LUN = 0;

    gReadCommand.lbn4 = (block &gt;&gt; 24) &amp; 0xFF;
    gReadCommand.lbn3 = (block &gt;&gt; 16) &amp; 0xFF;
    gReadCommand.lbn2 = (block &gt;&gt; 8) &amp; 0xFF;
    gReadCommand.lbn1 = block &amp; 0xFF;

    count = 1;
    gReadCommand.len2 = (count &gt;&gt; 8) &amp; 0xFF;
    gReadCommand.len1 = count &amp; 0xFF;

    status = DoSCSICommand(
		scsiDevice,
		<span class="enscript-string">&quot;\pRead&quot;</span>,
		(SCSI_CommandPtr) &amp;gReadCommand,
		(Ptr) address,
		count * block_size,
		scsiDirectionIn,
		NULL,
		&amp;senseData,
		errorText
	);
    <span class="enscript-keyword">if</span> (status == noErr) {
	rtn_value = 1;
    } <span class="enscript-keyword">else</span> {
	rtn_value = 0;
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">SCSI_WriteBlock</span>(UInt32 id, UInt32 bus, UInt32 block_size, UInt32 block, UInt8 *address)
{
    OSErr                   status;
    Str255                  errorText;
    <span class="enscript-type">char</span>*       msg;
    <span class="enscript-type">static</span> SCSI_10_Byte_Command gWriteCommand = {
	kScsiCmdWrite10, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    SCSI_Sense_Data         senseData;
    DeviceIdent scsiDevice;
    <span class="enscript-type">int</span> rtn_value;
    <span class="enscript-type">long</span> count;

    scsiDevice.diReserved = 0;
    scsiDevice.bus = bus;
    scsiDevice.targetID = id;
    scsiDevice.LUN = 0;

    gWriteCommand.lbn4 = (block &gt;&gt; 24) &amp; 0xFF;
    gWriteCommand.lbn3 = (block &gt;&gt; 16) &amp; 0xFF;
    gWriteCommand.lbn2 = (block &gt;&gt; 8) &amp; 0xFF;
    gWriteCommand.lbn1 = block &amp; 0xFF;

    count = 1;
    gWriteCommand.len2 = (count &gt;&gt; 8) &amp; 0xFF;
    gWriteCommand.len1 = count &amp; 0xFF;

    status = DoSCSICommand(
		scsiDevice,
		<span class="enscript-string">&quot;\pWrite&quot;</span>,
		(SCSI_CommandPtr) &amp;gWriteCommand,
		(Ptr) address,
		count * block_size,
		scsiDirectionOut,
		NULL,
		&amp;senseData,
		errorText
	);
    <span class="enscript-keyword">if</span> (status == noErr) {
	rtn_value = 1;
    } <span class="enscript-keyword">else</span> {
	rtn_value = 0;
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">DoReadCapacity</span>(UInt32 id, UInt32 bus, UInt32 *blockCount, UInt32 *blockSize)
{
    OSErr       status;
    Str255      errorText;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> SCSI_10_Byte_Command gCapacityCommand = {
	kScsiCmdReadCapacity, 0, 0, 0, 0, 0, 0, 0, 0, 0
    };
    SCSI_Sense_Data senseData;
    DeviceIdent     scsiDevice;
    SCSI_Capacity_Data  capacityData;
    UInt32      temp;
    <span class="enscript-type">int</span> rtn_value;

    scsiDevice.diReserved = 0;
    scsiDevice.bus = bus;
    scsiDevice.targetID = id;
    scsiDevice.LUN = 0;

    CLEAR(capacityData);

    status = DoSCSICommand(
		scsiDevice,
		<span class="enscript-string">&quot;\pRead Capacity&quot;</span>,
		(SCSI_CommandPtr) &amp;gCapacityCommand,
		(Ptr) &amp;capacityData,
		<span class="enscript-keyword">sizeof</span> (SCSI_Capacity_Data),
		scsiDirectionIn,
		NULL,
		&amp;senseData,
		errorText
		);

    <span class="enscript-keyword">if</span> (status == noErr) {
	temp = capacityData.lbn4;
	temp = (temp &lt;&lt; 8) | capacityData.lbn3;
	temp = (temp &lt;&lt; 8) | capacityData.lbn2;
	temp = (temp &lt;&lt; 8) | capacityData.lbn1;
	*blockCount = temp;

	temp = capacityData.len4;
	temp = (temp &lt;&lt; 8) | capacityData.len3;
	temp = (temp &lt;&lt; 8) | capacityData.len2;
	temp = (temp &lt;&lt; 8) | capacityData.len1;
	*blockSize = temp;

	rtn_value = 1;
    } <span class="enscript-keyword">else</span> {
	rtn_value = 0;
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">DoInquiry</span>(UInt32 id, UInt32 bus, UInt32 *devType)
{
    OSErr       status;
    Str255      errorText;
    <span class="enscript-type">static</span> <span class="enscript-type">const</span> SCSI_6_Byte_Command gInquiryCommand = {
	kScsiCmdInquiry, 0, 0, 0, kRequiredSCSIinquiryLength, 0
    };
    SCSI_Sense_Data senseData;
    DeviceIdent     scsiDevice;
    SCSI_Inquiry_Data  inquiryData;
    UInt32      temp;
    <span class="enscript-type">int</span> rtn_value;

    scsiDevice.diReserved = 0;
    scsiDevice.bus = bus;
    scsiDevice.targetID = id;
    scsiDevice.LUN = 0;

    CLEAR(inquiryData);

    status = DoSCSICommand(
		scsiDevice,
		<span class="enscript-string">&quot;\pInquiry&quot;</span>,
		(SCSI_CommandPtr) &amp;gInquiryCommand,
		(Ptr) &amp;inquiryData,
		kRequiredSCSIinquiryLength,
		scsiDirectionIn,
		NULL,
		&amp;senseData,
		errorText
		);

    <span class="enscript-keyword">if</span> (status == noErr) {
	*devType = inquiryData.devType &amp; kScsiDevTypeMask;
	rtn_value = 1;
    } <span class="enscript-keyword">else</span> {
	rtn_value = 0;
    }
    <span class="enscript-keyword">return</span> rtn_value;
}


MEDIA
<span class="enscript-function-name">SCSI_FindDevice</span>(<span class="enscript-type">long</span> dRefNum)
{
    SCSIDriverPB            pb;
    OSErr                   status;
    <span class="enscript-type">short</span>                   targetID;
    
    status = nsvErr;
    <span class="enscript-keyword">if</span> (AsyncSCSIPresent()) {
	clear_memory((Ptr) &amp;pb, <span class="enscript-keyword">sizeof</span> pb);
	
	pb.scsiPBLength = <span class="enscript-keyword">sizeof</span> (SCSIDriverPB);
	pb.scsiCompletion = NULL;
	pb.scsiFlags = 0;
	pb.scsiFunctionCode = SCSILookupRefNumXref;
	pb.scsiDevice.bus = kNoDevice;  <span class="enscript-comment">/* was *((long *) &amp;pb.scsiDevice) = 0xFFFFFFFFL; */</span>
	
	<span class="enscript-keyword">do</span> {
	    status = SCSIAction((SCSI_PB *) &amp;pb);
	    
	    <span class="enscript-keyword">if</span> (status != noErr) {
		<span class="enscript-keyword">break</span>;
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (pb.scsiDriver == dRefNum
		    &amp;&amp; pb.scsiDevice.bus != kNoDevice) {
		<span class="enscript-keyword">return</span> open_scsi_as_media(pb.scsiDevice.bus, pb.scsiDevice.targetID);

	    } <span class="enscript-keyword">else</span> {
		pb.scsiDevice = pb.scsiNextDevice;
	    }
	}
	<span class="enscript-keyword">while</span> (pb.scsiDevice.bus != kNoDevice);
    }
    <span class="enscript-keyword">if</span> (status == nsvErr) {
	<span class="enscript-comment">/*
	 * The asynchronous SCSI Manager is missing or the
	 * driver didn't register with the SCSI Manager.*/</span>
	targetID = DriverRefNumToSCSI(dRefNum);
	<span class="enscript-keyword">if</span> (targetID &gt;= 0 &amp;&amp; targetID &lt;= 6) {
	    <span class="enscript-keyword">return</span> open_old_scsi_as_media(targetID);
	}
    }
     <span class="enscript-keyword">return</span> 0;
}


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -


SCSI_MEDIA_ITERATOR
<span class="enscript-function-name">new_scsi_iterator</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> (SCSI_MEDIA_ITERATOR) new_media_iterator(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> SCSI_media_iterator));
}


MEDIA_ITERATOR
<span class="enscript-function-name">create_scsi_iterator</span>(<span class="enscript-type">void</span>)
{
    SCSI_MEDIA_ITERATOR a;
    
    <span class="enscript-keyword">if</span> (scsi_inited == 0) {
	scsi_init();
    }
    
    <span class="enscript-keyword">if</span> (scsi_mgr.exists == 0) {
	<span class="enscript-keyword">return</span> 0;
    }

    a = new_scsi_iterator();
    <span class="enscript-keyword">if</span> (a != 0) {
	a-&gt;m.kind = scsi_mgr.kind;
	a-&gt;m.state = kInit;
	a-&gt;m.do_reset = reset_scsi_iterator;
	a-&gt;m.do_step = step_scsi_iterator;
	a-&gt;m.do_delete = delete_scsi_iterator;
	a-&gt;bus_index = 0;
	a-&gt;bus = 0;
	a-&gt;id = 0;
    }

    <span class="enscript-keyword">return</span> (MEDIA_ITERATOR) a;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">reset_scsi_iterator</span>(MEDIA_ITERATOR m)
{
    SCSI_MEDIA_ITERATOR a;
    
    a = (SCSI_MEDIA_ITERATOR) m;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != scsi_mgr.kind) {
	<span class="enscript-comment">/* wrong kind - XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.state != kInit) {
	a-&gt;m.state = kReset;
    }
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">step_scsi_iterator</span>(MEDIA_ITERATOR m)
{
    SCSI_MEDIA_ITERATOR a;
    <span class="enscript-type">char</span> *result;
    
    a = (SCSI_MEDIA_ITERATOR) m;
    <span class="enscript-keyword">if</span> (a == 0) {
	<span class="enscript-comment">/* no media */</span>
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (a-&gt;m.kind != scsi_mgr.kind) {
	<span class="enscript-comment">/* wrong kind - XXX need to error here - this is an internal problem */</span>
    } <span class="enscript-keyword">else</span> {
	<span class="enscript-keyword">switch</span> (a-&gt;m.state) {
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kInit</span>:
	    <span class="enscript-comment">/* find # of buses - done in AllocatePB() out of scsi_init() */</span>
	    a-&gt;m.state = kReset;
	    <span class="enscript-comment">/* fall through to reset */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kReset</span>:
	    a-&gt;bus_index = 0 <span class="enscript-comment">/* first bus id */</span>;
	    a-&gt;bus = scsi_mgr.bus_list[a-&gt;bus_index].bus;
	    a-&gt;id = 0 <span class="enscript-comment">/* first device id */</span>;
	    a-&gt;m.state = kIterating;
	    clear_linux_cache();
	    <span class="enscript-comment">/* fall through to iterate */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kIterating</span>:
	    <span class="enscript-keyword">while</span> (1) {
		<span class="enscript-keyword">if</span> (a-&gt;bus_index &gt;= scsi_mgr.bus_count <span class="enscript-comment">/* max bus id */</span>) {
		    <span class="enscript-keyword">break</span>;
		}
		<span class="enscript-keyword">if</span> (a-&gt;id == scsi_mgr.bus_list[a-&gt;bus_index].master_id) {
		    <span class="enscript-comment">/* next id */</span>
		    a-&gt;id += 1;
		}
		<span class="enscript-keyword">if</span> (a-&gt;id &gt; scsi_mgr.bus_list[a-&gt;bus_index].max_id) {
		    a-&gt;bus_index += 1;
		    a-&gt;bus = scsi_mgr.bus_list[a-&gt;bus_index].bus;
		    a-&gt;id = 0 <span class="enscript-comment">/* first device id */</span>;
		    <span class="enscript-keyword">continue</span>;   <span class="enscript-comment">/* try again */</span>
		}
		<span class="enscript-comment">/* generate result */</span>
		result = (<span class="enscript-type">char</span> *) malloc(20);
		<span class="enscript-keyword">if</span> (result != NULL) {
		    <span class="enscript-keyword">if</span> (a-&gt;bus == 0xFF) {
			snprintf(result, 20, <span class="enscript-string">&quot;/dev/scsi%c&quot;</span>, <span class="enscript-string">'0'</span>+a-&gt;id);
			probe_scsi_device(a-&gt;bus, a-&gt;id, 1);
		    } <span class="enscript-keyword">else</span> {
			<span class="enscript-comment">// insure bus number in range
</span>			<span class="enscript-keyword">if</span> (a-&gt;bus &gt; 9) {
			    free(result);
			    result = NULL;
			    <span class="enscript-keyword">break</span>;
			}
			snprintf(result, 20, <span class="enscript-string">&quot;/dev/scsi%c.%c&quot;</span>,
			    <span class="enscript-string">'0'</span>+a-&gt;bus, <span class="enscript-string">'0'</span>+a-&gt;id);
			<span class="enscript-comment">/* only probe out of iterate; so always added in order. */</span>
			probe_scsi_device(a-&gt;bus, a-&gt;id, 0);
		    }
		}

		a-&gt;id += 1; <span class="enscript-comment">/* next id */</span>
		<span class="enscript-keyword">return</span> result;
	    }
	    a-&gt;m.state = kEnd;
	    <span class="enscript-comment">/* fall through to end */</span>
	<span class="enscript-keyword">case</span> <span class="enscript-reference">kEnd</span>:
	    mark_linux_cache_loaded();
	<span class="enscript-reference">default</span>:
	    <span class="enscript-keyword">break</span>;
	}
    }
    <span class="enscript-keyword">return</span> 0 <span class="enscript-comment">/* no entry */</span>;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">delete_scsi_iterator</span>(MEDIA_ITERATOR m)
{
    <span class="enscript-keyword">return</span>;
}


#<span class="enscript-reference">pragma</span> <span class="enscript-variable-name">mark</span> -


MEDIA
<span class="enscript-function-name">open_linux_scsi_as_media</span>(<span class="enscript-type">long</span> index, <span class="enscript-type">int</span> is_cdrom)
{
    MEDIA m;
    <span class="enscript-type">long</span> bus;
    <span class="enscript-type">long</span> id;
    
    <span class="enscript-keyword">if</span> (lookup_scsi_index(index, is_cdrom, &amp;bus, &amp;id) &gt; 0) {
	m = open_scsi_as_media(bus, id);
    } <span class="enscript-keyword">else</span> {
	m = 0;
    }
    
    <span class="enscript-keyword">return</span> m;
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">linux_old_scsi_name</span>(<span class="enscript-type">long</span> id)
{
    linux_scsi_name(kOriginalSCSIBusAdaptor, id);
}


<span class="enscript-type">char</span> *
<span class="enscript-function-name">linux_scsi_name</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id)
{
    <span class="enscript-type">char</span> *result = 0;
    <span class="enscript-type">long</span> value;
    <span class="enscript-type">int</span> is_cdrom;
    <span class="enscript-type">int</span> unsure;
    <span class="enscript-type">char</span> *suffix;

    <span class="enscript-comment">/* name is sda, sdb, sdc, ...
     * in order by buses and ids, but only count responding devices ...
     */</span>
    <span class="enscript-keyword">if</span> ((value = lookup_scsi_device(bus, id, &amp;is_cdrom, &amp;unsure)) &gt;= 0) {
	result = (<span class="enscript-type">char</span> *) malloc(20);
	<span class="enscript-keyword">if</span> (result != NULL) {
	    <span class="enscript-keyword">if</span> (unsure) {
		suffix = <span class="enscript-string">&quot; ?&quot;</span>;
	    } <span class="enscript-keyword">else</span> {
		suffix = <span class="enscript-string">&quot;&quot;</span>;
	    }
	    <span class="enscript-keyword">if</span> (is_cdrom) {
		<span class="enscript-keyword">if</span> (value &gt; 9) {
		    <span class="enscript-comment">// too many CD's, give up
</span>		    free(result); result = NULL;
		} <span class="enscript-keyword">else</span> {
		    snprintf(result, 20, <span class="enscript-string">&quot;/dev/scd%c%s&quot;</span>, <span class="enscript-string">'0'</span> + value, suffix);
		}
	    } <span class="enscript-keyword">else</span> {
		<span class="enscript-keyword">if</span> (value &lt; 26) {
		    snprintf(result, 20, <span class="enscript-string">&quot;/dev/sd%c%s&quot;</span>, <span class="enscript-string">'a'</span> + value, suffix);
		} <span class="enscript-keyword">else</span> {
		    snprintf(result, 20, <span class="enscript-string">&quot;/dev/sd%c%c%s&quot;</span>,
			    <span class="enscript-string">'a'</span> + value / 26, <span class="enscript-string">'a'</span> + value % 26, suffix);
		}
	    }
	}
    }
    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">probe_all</span>(<span class="enscript-type">void</span>)
{
    MEDIA_ITERATOR iter;
    <span class="enscript-type">char</span> *name;

    iter = create_scsi_iterator();
    <span class="enscript-keyword">if</span> (iter == 0) {
	<span class="enscript-keyword">return</span>;
    }

    printf(<span class="enscript-string">&quot;finding devices &quot;</span>);
    fflush(stdout);
    <span class="enscript-keyword">while</span> ((name = step_media_iterator(iter)) != 0) {
    	<span class="enscript-comment">/* step does the probe for us */</span>
	printf(<span class="enscript-string">&quot;.&quot;</span>);
	fflush(stdout);
	free(name);
    }
    delete_media_iterator(iter);
    printf(<span class="enscript-string">&quot;\n&quot;</span>);
    fflush(stdout);
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">probe_scsi_device</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id, <span class="enscript-type">int</span> unsure)
{
    UInt32 devType;
    
    <span class="enscript-keyword">if</span> (DoInquiry(id, bus, &amp;devType)) {
    	<span class="enscript-keyword">if</span> (devType == kScsiDevTypeDirect
    		|| devType == kScsiDevTypeOptical) {
    	    add_to_cache(bus, id, 0, unsure);
    	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (devType == kScsiDevTypeCDROM
		|| devType == kScsiDevTypeWorm) {
    	    add_to_cache(bus, id, 1, unsure);
    	}
    }
}


<span class="enscript-type">long</span>
<span class="enscript-function-name">lookup_scsi_device</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id, <span class="enscript-type">int</span> *is_cdrom, <span class="enscript-type">int</span> *unsure)
{
    <span class="enscript-comment">/* walk down list looking for bus and id ?
     *
     * only probe out of iterate (so always add in order)
     * reset list if we reset the iterate
     */</span>
    <span class="enscript-type">struct</span> cache_item *item;
    <span class="enscript-type">struct</span> cache_item *next;
    <span class="enscript-type">long</span> result = -1;
    <span class="enscript-type">int</span> count = 0;
    
    <span class="enscript-keyword">if</span> (scsi_inited == 0) {
	scsi_init();
    }

    <span class="enscript-keyword">while</span> (1) {
    	count++;
	<span class="enscript-keyword">for</span> (item = linux_order.first; item != NULL; item = item-&gt;next) {
	    <span class="enscript-keyword">if</span> (item-&gt;bus == bus &amp;&amp; item-&gt;id == id) {
		result = item-&gt;value;
		*is_cdrom = item-&gt;is_cdrom;
		*unsure = item-&gt;unsure;
		<span class="enscript-keyword">break</span>;
	    }
	}
	<span class="enscript-keyword">if</span> (count &lt; 2 &amp;&amp; result &lt; 0) {
	    probe_all();
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-keyword">break</span>;
	}
    };

    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-comment">/*
 * This has the same structure as lookup_scsi_device() except we are
 * matching on the value &amp; type rather than the bus &amp; id.
 */</span>
<span class="enscript-type">long</span>
<span class="enscript-function-name">lookup_scsi_index</span>(<span class="enscript-type">long</span> index, <span class="enscript-type">int</span> is_cdrom, <span class="enscript-type">long</span> *bus, <span class="enscript-type">long</span> *id)
{
    <span class="enscript-type">struct</span> cache_item *item;
    <span class="enscript-type">struct</span> cache_item *next;
    <span class="enscript-type">long</span> result = 0;
    <span class="enscript-type">int</span> count = 0;
    
    <span class="enscript-keyword">if</span> (scsi_inited == 0) {
	scsi_init();
    }

    <span class="enscript-keyword">while</span> (1) {
    	count++;
	<span class="enscript-keyword">for</span> (item = linux_order.first; item != NULL; item = item-&gt;next) {
	    <span class="enscript-keyword">if</span> (item-&gt;value == index &amp;&amp; item-&gt;is_cdrom == is_cdrom
		    &amp;&amp; item-&gt;unsure == 0) {
		result = 1;
		*bus = item-&gt;bus;
		*id = item-&gt;id;
		<span class="enscript-keyword">break</span>;
	    }
	}
	<span class="enscript-keyword">if</span> (count &lt; 2 &amp;&amp; result == 0 &amp;&amp; !linux_cache_loaded()) {
	    probe_all();
	} <span class="enscript-keyword">else</span> {
	    <span class="enscript-keyword">break</span>;
	}
    };

    <span class="enscript-keyword">return</span> result;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">add_to_cache</span>(<span class="enscript-type">long</span> bus, <span class="enscript-type">long</span> id, <span class="enscript-type">int</span> is_cdrom, <span class="enscript-type">int</span> unsure)
{
    <span class="enscript-type">struct</span> cache_item *item;
    
    item = malloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> cache_item));
    <span class="enscript-keyword">if</span> (item == NULL) {
	<span class="enscript-keyword">return</span>;
    } <span class="enscript-keyword">else</span> {
	item-&gt;bus = bus;
	item-&gt;id = id;
	item-&gt;is_cdrom = is_cdrom;
	item-&gt;unsure = unsure;
	<span class="enscript-keyword">if</span> (is_cdrom) {
	    item-&gt;value = linux_order.next_cdrom;
	    linux_order.next_cdrom++;
	} <span class="enscript-keyword">else</span> {
	    item-&gt;value = linux_order.next_disk;
	    linux_order.next_disk++;
	}
	item-&gt;next = 0;
    }
    <span class="enscript-keyword">if</span> (linux_order.first == NULL) {
	linux_order.first = item;
	linux_order.last = item;
    } <span class="enscript-keyword">else</span> {
	linux_order.last-&gt;next = item;
	linux_order.last = item;
    }
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">init_linux_cache</span>(<span class="enscript-type">void</span>)
{
    linux_order.first = NULL;
    clear_linux_cache();
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">clear_linux_cache</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-type">struct</span> cache_item *item;
    <span class="enscript-type">struct</span> cache_item *next;
    
    <span class="enscript-keyword">for</span> (item = linux_order.first; item != NULL; item = next) {
	next = item-&gt;next;
	free(item);
    }
    <span class="enscript-comment">/* back to starting value */</span>
    linux_order.first = NULL;
    linux_order.last = NULL;
    linux_order.next_disk = 0;
    linux_order.next_cdrom = 0;
    linux_order.loaded = 0;
}


<span class="enscript-type">void</span>
<span class="enscript-function-name">mark_linux_cache_loaded</span>(<span class="enscript-type">void</span>)
{
    linux_order.loaded = 1;
}


<span class="enscript-type">int</span>
<span class="enscript-function-name">linux_cache_loaded</span>(<span class="enscript-type">void</span>)
{
    <span class="enscript-keyword">return</span> linux_order.loaded;
}
</pre>
<hr />
</body></html>